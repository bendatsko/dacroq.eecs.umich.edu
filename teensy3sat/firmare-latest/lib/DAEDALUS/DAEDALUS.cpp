// Project: DAEDALUS Teensy Test Bench
// Authors: Luke Wormald

#include "DAEDALUS.h"

/*
    Constructor function
*/
DAEDALUS::DAEDALUS()
{
}

/*
    Setup functions
*/
void DAEDALUS::setup(uint8_t CS, bool clkExt, uint8_t clkIntFrq, uint8_t clkDiv)
{
    EXPIO.setup();
    Digi_pot.setup(EXPIO);
    DAC.setup(Digi_pot);
    SPI_CS_CHIP_PIN = CS;
    // Configure pin modes of digital control pins
    pinMode(SYS_PAUSE_DIE1, INPUT);
    pinMode(SYS_PAUSE_DIE2, INPUT);
    pinMode(SYS_TERM_DIE1, INPUT);
    pinMode(SYS_TERM_DIE2, INPUT);
    pinMode(SPI_CS_CHIP_PIN, OUTPUT);
    digitalWriteFast(SPI_CS_CHIP_PIN, HIGH);

    pinMode(SPI_CS_CHIP_PIN, OUTPUT);

    SPI.begin(); // Initialize SPI bus
    DAC_setup(0.395, 0.095, 0.5, 0.3, 0.245, 0.915, 0.915, 0.2, 0.9, 0.5, 0.4, 0.55, 0.245);
    IBIAS_setup();

    uint8_t expander_data1 = 0, expander_data2 = 0;
    /*
        Startup Sequence
    */
    EXPIO.write_chip_reset(LOW);   // Hold system reset low
    delayMicroseconds(500);        // Delay to let reset propagate
    EXPIO.write_clkgen_reset(LOW); // Hold clock generator reset low

    // Setup digital clock
    if (clkExt) // If using external clock (100MHz max)
    {
        EXPIO.write_bypass(HIGH); // Select external clock

        // Minimize internal clock frequency to reduce power
        EXPIO.write_clkgen_osc(0x07);
    }
    else // If using internal ring oscillator
    {
        EXPIO.write_bypass(LOW); // Select internal clock

        // Set internal clk frequency
        EXPIO.write_clkgen_osc(clkIntFrq);
    }

    // Set clock divider
    EXPIO.write_clkgen_div(clkDiv);
    EXPIO.readPCA9671_0(expander_data1, expander_data2);
    // SerialUSB.println("READ_PCA9671_start_setup ("+String(expander_data1)+").");
    EXPIO.write_clkgen_reset(HIGH); // Release clock generator reset

    //    delay(100); // Wait for clock to stabilize
    EXPIO.write_chip_reset(HIGH); // Release system reset pin
    SerialUSB.println("Wait for clock to stabilize.");
    //    delay(5000); // Wait for clock to stabilize

    /*
        SPI Setup
    */
    writeConfigReg(W_REG1, 30);   // Setup dummy cycle between write and read
    writeConfigReg(W_REG0, 0x00); // Set to single SPI mode

    EXPIO.readPCA9671_0(expander_data1, expander_data2);
    // SerialUSB.println("READ_PCA9671_end_setup ("+String(expander_data1)+").");
    setupFilesystem();
}
void DAEDALUS::setup_iteration(uint8_t CS, bool clkExt, uint8_t clkIntFrq, uint8_t clkDiv)
{
    // EXPIO.setup();
    // Digi_pot.setup(EXPIO);
    // DAC.setup(Digi_pot);
    // SPI_CS_CHIP_PIN = CS;
    // Configure pin modes of digital control pins
    // pinMode(SYS_PAUSE_DIE1, INPUT);
    // pinMode(SYS_PAUSE_DIE2, INPUT);
    // pinMode(SYS_TERM_DIE1, INPUT);
    // pinMode(SYS_TERM_DIE2, INPUT);
    // pinMode(SPI_CS_CHIP_PIN, OUTPUT);
    // digitalWriteFast(SPI_CS_CHIP_PIN, HIGH);

    // pinMode(SPI_CS_CHIP_PIN, OUTPUT);

    // SPI.begin();    // Initialize SPI bus
    // DAC_setup(0.395, 0.095, 0.5, 0.3, 0.245, 0.92, 0.9, 0.2, 0.9, 0.5, 0.4, 0.55, 0.245);
    // IBIAS_setup();

    uint8_t expander_data1 = 0, expander_data2 = 0;
    /*
        Startup Sequence
    */
    EXPIO.write_chip_reset(LOW);   // Hold system reset low
    delayMicroseconds(500);        // Delay to let reset propagate
    EXPIO.write_clkgen_reset(LOW); // Hold clock generator reset low

    // Setup digital clock
    if (clkExt) // If using external clock (100MHz max)
    {
        EXPIO.write_bypass(HIGH); // Select external clock

        // Minimize internal clock frequency to reduce power
        EXPIO.write_clkgen_osc(0x07);
    }
    else // If using internal ring oscillator
    {
        EXPIO.write_bypass(LOW); // Select internal clock

        // Set internal clk frequency
        EXPIO.write_clkgen_osc(clkIntFrq);
    }

    // Set clock divider
    EXPIO.write_clkgen_div(clkDiv);
    // EXPIO.readPCA9671_0(expander_data1, expander_data2);
    // SerialUSB.println("READ_PCA9671_start_setup ("+String(expander_data1)+").");
    EXPIO.write_clkgen_reset(HIGH); // Release clock generator reset

    //    delay(100); // Wait for clock to stabilize
    EXPIO.write_chip_reset(HIGH); // Release system reset pin
    // SerialUSB.println("Wait for clock to stabilize.");
    //    delay(500); // Wait for clock to stabilize

    /*
        SPI Setup
    */
    writeConfigReg(W_REG1, 30);   // Setup dummy cycle between write and read
    writeConfigReg(W_REG0, 0x00); // Set to single SPI mode

    // EXPIO.readPCA9671_0(expander_data1, expander_data2);
    // SerialUSB.println("READ_PCA9671_end_setup ("+String(expander_data1)+").");
    // setupFilesystem();
}
void DAEDALUS::startup()
{
    // ========= Begin scan chain setup - modified 7/29/24 =========
    const int CLOCK_PIN = 31; // inf_scan_clk_out_o_H

    // Channel 1 pins
    const int DATA_IN_1 = 33, DATA_OUT_1 = 34, ENABLE_1 = 16; // imf_scan_in0_i_H, imf_scan_out0_H, imf_scan_write_enable_die0_H

    // Channel 2 pins
    const int DATA_IN_2 = 35, DATA_OUT_2 = 36, ENABLE_2 = 17; // imf_scan_in1_i_H, imf_scan_out1_o_H, imf_scan_write_en_die1_H

    // Channel 3 pins
    const int DATA_IN_3 = 37, DATA_OUT_3 = 38, ENABLE_3 = 0; // imf_scan_in2_i_H, imf_scan_out2_o_H, no enable shown in schematic

    // CHAIN_LENGTH defines the number of bits in each shift register of the scan chain
    // This means each channel can hold and transfer 8 bits of data at a time
    const int CHAIN_LENGTH = 8;

    // Set the clock speed for the scan chain (1 MHz)
    const unsigned long CLOCK_SPEED = 100000; // 1 MHz

    // Initialize the ScanChain object with the defined parameters
    ScanChain scanChain(CHAIN_LENGTH, CLOCK_PIN, DATA_IN_1, DATA_OUT_1, ENABLE_1, DATA_IN_2, DATA_OUT_2, ENABLE_2, DATA_IN_3, DATA_OUT_3, ENABLE_3);

    // Define the size of the data to be transferred (32 KB)
    const size_t DATA_SIZE = 32 * 1024; // 32 KB
    uint8_t largeData[DATA_SIZE];

    // Initialize the scan chain with the specified clock speed
    scanChain.begin(CLOCK_SPEED);

    // Fill largeData array with a simple pattern for testing
    for (size_t i = 0; i < DATA_SIZE; i++)
    {
        largeData[i] = i & 0xFF;
    }

    // Load data into the teensy's memory
    scanChain.loadDataFromMemory(largeData, DATA_SIZE);

    // Start scan chain operation
    scanChain.run();

    // originally in loop - should probably go somewhere else
    // function: checks to see if transfer has completed
    //
    // if (scanChain.isComplete())
    // {
    //     Serial.println("Transfer complete");
    //     scanChain.stop();
    //     while (1); // Stop execution
    // }
}
void DAEDALUS::DAC_setup(float VREF_FL2, float VREF_FL0, float VREF_DUM, float VREF_INJ2, float VREF_FL1, float VDD_A, float VDD_AIO, float VREF_INJ3, float VCM_IMF, float VREF_INJ0, float VREF_INJ1, float VCM_TIA, float VCM_FL)
{
    DAC.setConfig(DAC0);
    DAC.setConfig(DAC1);

    DAC.setGain(DAC0);
    DAC.setGain(DAC1);

    DAC.setSync(DAC0);
    DAC.setSync(DAC1);

    DAC.setDAC0(DAC.voltageToCode(VREF_FL2, DAC0_ADDR), DAC0);
    DAC.setDAC1(DAC.voltageToCode(VREF_FL0, DAC1_ADDR), DAC0);
    DAC.setDAC2(DAC.voltageToCode(VREF_DUM, DAC2_ADDR), DAC0);
    DAC.setDAC3(DAC.voltageToCode(VREF_INJ2, DAC3_ADDR), DAC0);
    DAC.setDAC4(DAC.voltageToCode(VREF_FL1, DAC4_ADDR), DAC0);
    DAC.setDAC5(DAC.voltageToCode(VDD_A, DAC5_ADDR), DAC0);
    DAC.setDAC6(DAC.voltageToCode(VDD_A, DAC6_ADDR), DAC0);
    DAC.setDAC7(DAC.voltageToCode(VDD_A, DAC7_ADDR), DAC0);

    DAC.setDAC0(DAC.voltageToCode(VDD_AIO, DAC0_ADDR), DAC1);
    DAC.setDAC1(DAC.voltageToCode(VDD_AIO, DAC1_ADDR), DAC1);
    DAC.setDAC2(DAC.voltageToCode(VREF_INJ3, DAC2_ADDR), DAC1);
    DAC.setDAC3(DAC.voltageToCode(VCM_IMF, DAC3_ADDR), DAC1);
    DAC.setDAC4(DAC.voltageToCode(VREF_INJ0, DAC4_ADDR), DAC1);
    DAC.setDAC5(DAC.voltageToCode(VREF_INJ1, DAC5_ADDR), DAC1);
    DAC.setDAC6(DAC.voltageToCode(VCM_TIA, DAC6_ADDR), DAC1);
    DAC.setDAC7(DAC.voltageToCode(VCM_FL, DAC7_ADDR), DAC1);
}

void DAEDALUS::IBIAS_setup()
{
    // uint16_t value = 8;    // Set bias current to 0
    uint16_t value_D1_I0_comp = 9;   // CMP 9-->75u
    uint16_t value_D1_I1_flash = 13; // FLASH 13-->52uA
    uint16_t value_D1_I2 = 35;       // DLL bias 140-->5uA 350-->2uA
    uint16_t value_D1_I3_rxo = 150;  // RXO bias 35-->20uA  150-->1MHz
    uint16_t value_D1_I4 = 16;
    uint16_t value_D1_I5_clause = 37;
    uint16_t value_D1_I6_TIA = 13; // TIA

    uint16_t value_D2_I0_comp = 9;
    uint16_t value_D2_I1_flash = 13;
    uint16_t value_D2_I2 = 35;     // 140-->5uA
    uint16_t value_D2_I3_rxo = 35; //
    uint16_t value_D2_I4 = 16;
    uint16_t value_D2_I5_clause = 37;
    uint16_t value_D2_I6_TIA = 13;

    Digi_pot.writeRDAC(2, D1_Ibias0, value_D1_I0_comp); // D1_Ibias0 is put in the second expander(Expander[1]) not the first expander(Expander[0])
    Digi_pot.writeRDAC(1, D1_Ibias1, value_D1_I1_flash);
    Digi_pot.writeRDAC(1, D1_Ibias2, value_D1_I2);
    Digi_pot.writeRDAC(1, D1_Ibias3, value_D1_I3_rxo);
    Digi_pot.writeRDAC(1, D1_Ibias4, value_D1_I4);
    Digi_pot.writeRDAC(1, D1_Ibias5, value_D1_I5_clause);
    Digi_pot.writeRDAC(1, D1_Ibias6, value_D1_I6_TIA);

    Digi_pot.writeRDAC(2, D2_Ibias0, value_D2_I0_comp);
    Digi_pot.writeRDAC(2, D2_Ibias1, value_D2_I1_flash);
    Digi_pot.writeRDAC(2, D2_Ibias2, value_D2_I2);
    Digi_pot.writeRDAC(2, D2_Ibias3, value_D2_I3_rxo);
    Digi_pot.writeRDAC(2, D2_Ibias4, value_D2_I4);
    Digi_pot.writeRDAC(2, D2_Ibias5, value_D2_I5_clause);
    Digi_pot.writeRDAC(2, D2_Ibias6, value_D2_I6_TIA);
}
void DAEDALUS::IBIAS_setup(uint16_t *value_sets)
{
    // uint16_t value = 8;    // Set bias current to 0
    uint16_t value_D1_I0_comp = value_sets[0];  // CMP 9-->75u
    uint16_t value_D1_I1_flash = value_sets[1]; // FLASH 13-->52uA
    uint16_t value_D1_I2 = value_sets[2];       // DLL bias 140-->5uA 350-->2uA
    uint16_t value_D1_I3_rxo = value_sets[3];   // RXO bias 35-->20uA  150-->1MHz
    uint16_t value_D1_I4 = value_sets[4];
    uint16_t value_D1_I5_clause = value_sets[5];
    uint16_t value_D1_I6_TIA = value_sets[6]; // TIA

    uint16_t value_D2_I0_comp = value_sets[7];
    uint16_t value_D2_I1_flash = value_sets[8];
    uint16_t value_D2_I2 = value_sets[9];      // 140-->5uA
    uint16_t value_D2_I3_rxo = value_sets[10]; //
    uint16_t value_D2_I4 = value_sets[11];
    uint16_t value_D2_I5_clause = value_sets[12];
    uint16_t value_D2_I6_TIA = value_sets[13];

    Digi_pot.writeRDAC(2, D1_Ibias0, value_D1_I0_comp); // D1_Ibias0 is put in the second expander(Expander[1]) not the first expander(Expander[0])
    Digi_pot.writeRDAC(1, D1_Ibias1, value_D1_I1_flash);
    Digi_pot.writeRDAC(1, D1_Ibias2, value_D1_I2);
    Digi_pot.writeRDAC(1, D1_Ibias3, value_D1_I3_rxo);
    Digi_pot.writeRDAC(1, D1_Ibias4, value_D1_I4);
    Digi_pot.writeRDAC(1, D1_Ibias5, value_D1_I5_clause);
    Digi_pot.writeRDAC(1, D1_Ibias6, value_D1_I6_TIA);

    Digi_pot.writeRDAC(2, D2_Ibias0, value_D2_I0_comp);
    Digi_pot.writeRDAC(2, D2_Ibias1, value_D2_I1_flash);
    Digi_pot.writeRDAC(2, D2_Ibias2, value_D2_I2);
    Digi_pot.writeRDAC(2, D2_Ibias3, value_D2_I3_rxo);
    Digi_pot.writeRDAC(2, D2_Ibias4, value_D2_I4);
    Digi_pot.writeRDAC(2, D2_Ibias5, value_D2_I5_clause);
    Digi_pot.writeRDAC(2, D2_Ibias6, value_D2_I6_TIA);
}
/*
    Communication functions
*/
void DAEDALUS::writeConfigReg(uint8_t cmd, uint8_t data) // Write data to SPI configuration register
{
    SPI.beginTransaction(DAEDALUS_SPI_Settings); // Configure the SPI controller for transmission

    digitalWriteFast(SPI_CS_CHIP_PIN, LOW);  // Set the chip select low
    SPI.transfer(cmd);                       // Transmit the command register
    SPI.transfer(data);                      // Transmit the data
    digitalWriteFast(SPI_CS_CHIP_PIN, HIGH); // Set the chip select high

    SPI.endTransaction(); // Release the SPI Controller
}

void DAEDALUS::writeReg(uint32_t addr, uint32_t data) // Write data to DAC register
{
    SPI.beginTransaction(DAEDALUS_SPI_Settings); // Configure the SPI controller for transmission

    digitalWriteFast(SPI_CS_CHIP_PIN, LOW);  // Set the chip select low
    SPI.transfer(WRITE);                     // Transmit the command register
    SPI.transfer32(addr);                    // Transmit the address register
    SPI.transfer32(data);                    // Transmit the data
    digitalWriteFast(SPI_CS_CHIP_PIN, HIGH); // Set the chip select high

    SPI.endTransaction(); // Release the SPI Controller
}

uint32_t DAEDALUS::readReg(uint32_t addr) // Read data from DAC register
{
    // Initialize transmission buffer
    uint8_t buffer[13] = {0};
    buffer[0] = 0x0B;

    // Load address into the transmission buffer
    buffer[1] = (addr & 0xFF000000) >> 24;
    buffer[2] = (addr & 0x00FF0000) >> 16;
    buffer[3] = (addr & 0x0000FF00) >> 8;
    buffer[4] = (addr & 0x000000FF);

    // Initialize return buffer
    uint8_t bufferOut[13] = {0};

    SPI.beginTransaction(DAEDALUS_SPI_Settings);

    digitalWriteFast(SPI_CS_CHIP_PIN, LOW);  // Set the chip select low
    SPI.transfer(&buffer, &bufferOut, 13);   // Transmit the buffer and pass the return buffer
    digitalWriteFast(SPI_CS_CHIP_PIN, HIGH); // Set the chip select high
    SPI.endTransaction();                    // Release the SPI controller

    delayMicroseconds(100);

    uint32_t data = (bufferOut[9] << 24) | (bufferOut[10] << 16) | (bufferOut[11] << 8) | bufferOut[12]; // Read data out of the return buffer
    return data;
}

void DAEDALUS::reset() // Reset digital core
{
    EXPIO.write_chip_reset(LOW);
    delayMicroseconds(500);
    EXPIO.write_chip_reset(HIGH);
}

// /*
//     Program functions
// */

void DAEDALUS::Read_data()
{
    while (1)
    {
        // uint32_t reg_data_chip0 = 0;
        // reg_data_chip0 = readReg(CONTROL_REGS+STATUS_SYS_INFO*4);
        // if ((reg_data_chip0 & 0x00000008)==0x00000008)
        // {
        // break;
        // }
        bool reg_data_chip0_pause = 0;
        // bool reg_data_chip0_term = 0;
        reg_data_chip0_pause = digitalReadFast(SYS_PAUSE_DIE1);
        // reg_data_chip0_term = digitalReadFast(SYS_TERM_DIE1);
        if (reg_data_chip0_pause == 1)
        {
            break;
        }
    }
    uint32_t reg_data_chip0_temp = 0;
    reg_data_chip0_temp = readReg(CONTROL_REGS + STATUS_SYS_INFO * 4);
    SerialUSB.println("Status: " + String(reg_data_chip0_temp, BIN) + " ");
    uint32_t oscillator_data0[14] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    oscillator_data0[0] = readReg(SAMPLE_REGS + 0 * 4);
    oscillator_data0[1] = readReg(SAMPLE_REGS + 1 * 4);
    oscillator_data0[2] = readReg(SAMPLE_REGS + 2 * 4);
    oscillator_data0[3] = readReg(SAMPLE_REGS + 3 * 4);
    oscillator_data0[4] = readReg(SAMPLE_REGS + 4 * 4);
    oscillator_data0[5] = readReg(SAMPLE_REGS + 5 * 4);
    oscillator_data0[6] = readReg(SAMPLE_REGS + 6 * 4);
    oscillator_data0[7] = readReg(SAMPLE_REGS + 7 * 4);
    oscillator_data0[8] = readReg(SAMPLE_REGS + 8 * 4);
    oscillator_data0[9] = readReg(SAMPLE_REGS + 9 * 4);
    oscillator_data0[10] = readReg(SAMPLE_REGS + 10 * 4);
    oscillator_data0[11] = readReg(SAMPLE_REGS + 11 * 4);
    oscillator_data0[12] = readReg(SAMPLE_REGS + 12 * 4);
    oscillator_data0[13] = readReg(SAMPLE_REGS + 13 * 4);
    bool oscillator_states[56];
    for (int j = 0; j < 52; j++)
    {
        oscillator_states[j] = 0;
    }
    for (int x = 0; x < 14; x++)
    {
        for (int y = 0; y < 4; y++)
        {
            if (y == 0)
            {
                oscillator_states[x * 4 + y] = ((oscillator_data0[x] & (0x00000008)) == (0x00000008));
            }
            else if (y == 1)
            {
                oscillator_states[x * 4 + y] = ((oscillator_data0[x] & (0x00000800)) == (0x00000800));
            }
            else if (y == 2)
            {
                oscillator_states[x * 4 + y] = ((oscillator_data0[x] & (0x00080000)) == (0x00080000));
            }
            else if (y == 3)
            {
                oscillator_states[x * 4 + y] = ((oscillator_data0[x] & (0x08000000)) == (0x08000000));
            }
        }
    }
    // uint64_t oscillator_states_selected = 0;
    uint32_t oscillator_states_selected_v2_half0 = 0;
    uint32_t oscillator_states_selected_v2_half1 = 0;
    for (int add = 0; add < 56; add++)
    {
        if (add < 32)
        {
            oscillator_states_selected_v2_half0 = oscillator_states_selected_v2_half0 | (oscillator_states[add] << add);
        }
        else
        {
            oscillator_states_selected_v2_half1 = oscillator_states_selected_v2_half1 | (oscillator_states[add] << (add - 32));
        }
    }
    // uint32_t oscillator_states_selected_half0 = (oscillator_states_selected);
    // uint32_t oscillator_states_selected_half1 = (oscillator_states_selected)>>32;

    for (int i = 0; i < 14; i++)
    {
        SerialUSB.println("Oscillator[" + String(i) + "]: " + String(oscillator_data0[i], BIN) + " ");
    }
    SerialUSB.println("Oscillator_long[" + String(0) + "]: " + String(oscillator_states_selected_v2_half0, BIN) + " ");
    SerialUSB.println("Oscillator_long[" + String(1) + "]: " + String(oscillator_states_selected_v2_half1, BIN) + " ");
    uint32_t total_cycles = 0;
    total_cycles = readReg(CONTROL_REGS + STATUS_TOTAL_CYC * 4);
    SerialUSB.println("Total cycles: " + String(total_cycles, DEC) + " ");

    uint32_t reg_data_chip0 = readReg(CONTROL_REGS + STATUS_CUR_PC * 4);
    SerialUSB.println("Current PC: " + String(reg_data_chip0, HEX) + " ");
    total_cycles = readReg(CONTROL_REGS + STATUS_TOTAL_CYC * 4);
    SerialUSB.println("Total cycles: " + String(total_cycles, DEC) + " ");
    reg_data_chip0 = readReg(CONTROL_REGS + STATUS_CUR_PC * 4);
    SerialUSB.println("Current PC: " + String(reg_data_chip0, HEX) + " ");
}
void DAEDALUS::Multi_run()
{
    // uf20-01
    uint64_t data0[228] = {3377699720527880, 3377699720527876, 2251799813685264, 2251799814209536, 3377699720528384, 2251799813687296, 3377699720593408, 2251799813718016, 3377699720528896, 3377699720658944, 2251799813685252, 2251799813685280, 2251799813816320, 2251799813947392, 3377699720529920, 2251799813685376, 2251799813685376, 3377699720527936, 3377699720529920, 2251799813685760, 3377699720527874, 3377699720528128, 2251799813686272, 3377699720528128, 3377699720529920, 2251799813816320, 3377699721052160, 3377699720790016, 2251799813718016, 2251799813685249, 2251799813689344, 2251799813687296, 3377699720529920, 2251799813685312, 3377699720527904, 3377699721052160, 2251799813947392, 2251799813685312, 2251799813685264, 2251799813685256, 3377699720529920, 2251799813685264, 3377699720527873, 3377699721052160, 3377699720531968, 3377699720536064, 2251799813685264, 3377699720528384, 2251799813718016, 3377699720560640, 2251799813701632, 3377699720527880, 2251799813685760, 2251799813685376, 3377699720536064, 3377699720527873, 2251799813689344, 2251799813685312, 3377699720527873, 2251799813685250, 3377699720544256, 2251799813686272, 2251799813685280, 3377699720527888, 2251799813685280, 2251799813689344, 3377699721052160, 3377699720528128, 2251799813685264, 2251799813687296, 2251799813816320, 3377699720544256, 3377699720528128, 3377699720528384, 3377699721052160, 2251799813685504, 2251799813685264, 3377699720527874, 2251799813816320, 3377699720527936, 2251799813701632, 2251799813685250, 3377699720529920, 2251799813685250, 3377699721052160, 2251799813685264, 2251799814209536, 2251799813685504, 2251799813947392, 3377699720529920, 3377699720527880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    uint64_t data1[228] = {2251799813816320, 3377699720658944, 2251799813685376, 3377699720527936, 2251799813689344, 2251799813685504, 3377699720790016, 3377699720528128, 2251799813685264, 2251799813685760, 3377699720528896, 2251799813750784, 3377699720536064, 2251799813701632, 3377699720658944, 3377699720527880, 2251799813685504, 3377699720593408, 2251799813685312, 2251799813686272, 2251799813701632, 3377699720527904, 3377699721052160, 2251799813701632, 2251799813685312, 2251799813685250, 3377699720529920, 3377699720528896, 3377699720658944, 2251799813750784, 3377699720544256, 2251799813693440, 2251799813693440, 3377699720560640, 3377699720528384, 3377699720536064, 3377699720593408, 3377699720527873, 3377699720529920, 2251799813685504, 2251799813686272, 3377699720790016, 3377699720560640, 2251799813693440, 2251799813685256, 3377699720527936, 3377699720528128, 3377699720527873, 2251799813701632, 3377699720527876, 2251799813685760, 2251799813701632, 2251799813718016, 3377699720529920, 2251799813685280, 3377699720527904, 2251799813685264, 2251799813685250, 2251799814209536, 2251799813689344, 3377699720658944, 3377699720536064, 2251799813701632, 2251799813687296, 3377699720593408, 3377699720527888, 2251799813685249, 2251799813750784, 3377699720790016, 3377699720528000, 3377699720536064, 2251799813685504, 2251799813685264, 2251799813947392, 3377699720528128, 2251799813685250, 3377699720531968, 2251799813685760, 3377699720527876, 2251799813685504, 2251799813685280, 3377699720527876, 3377699720527876, 2251799813685252, 2251799813701632, 2251799813750784, 2251799813816320, 3377699720527873, 3377699720528128, 2251799813685250, 2251799813718016, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    uint64_t data2[228] = {3377699720790016, 2251799813685264, 2251799813701632, 2251799813718016, 2251799813685312, 3377699720593408, 3377699720527888, 3377699720544256, 2251799813693440, 3377699720531968, 3377699720529920, 2251799813685376, 3377699720527873, 3377699720528384, 2251799813947392, 3377699720527936, 3377699720527880, 2251799813701632, 2251799813693440, 3377699720528000, 2251799813686272, 3377699720527873, 2251799813750784, 3377699720531968, 2251799813750784, 3377699721052160, 3377699720527880, 3377699720536064, 2251799813685256, 2251799813947392, 3377699720528384, 2251799813689344, 2251799813685312, 3377699720528384, 3377699720527936, 2251799813718016, 3377699720528896, 2251799814209536, 3377699720544256, 2251799813689344, 2251799813685312, 2251799813685376, 3377699720593408, 2251799813701632, 3377699720528384, 3377699720528384, 3377699721052160, 2251799813947392, 2251799813685249, 2251799813686272, 3377699720527880, 2251799813685252, 3377699720528896, 2251799813685264, 3377699720529920, 3377699720528896, 2251799813685249, 3377699720529920, 3377699720790016, 2251799813685376, 3377699720527880, 3377699720528128, 2251799813685250, 2251799813701632, 3377699720527888, 2251799813947392, 3377699720536064, 3377699720544256, 2251799813816320, 2251799813685760, 2251799813685256, 3377699720531968, 2251799813685249, 2251799813693440, 3377699720527880, 3377699720790016, 2251799813750784, 2251799813816320, 3377699720528896, 3377699720593408, 2251799813685252, 2251799813689344, 2251799813685250, 3377699720593408, 2251799813718016, 2251799813947392, 3377699720528896, 2251799813685264, 3377699720593408, 3377699720593408, 2251799813685264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    // uf20-02
    //  uint64_t data0[228]={2251799813685760,3377699720560640,2251799813750784,2251799813685760,2251799813685249,3377699720527876,2251799813689344,2251799813685250,3377699720527936,2251799813685312,3377699720527874,3377699720527874,3377699720527936,2251799813686272,3377699720527876,2251799813685252,2251799813689344,3377699720527888,3377699721052160,2251799813689344,2251799813685264,3377699720528128,2251799813687296,2251799814209536,3377699720529920,3377699720527904,3377699720531968,2251799814209536,2251799813685760,2251799813685312,3377699720790016,3377699720790016,2251799813685250,2251799813685376,2251799813689344,3377699720544256,2251799813750784,3377699720790016,3377699720527936,2251799813685252,3377699720527936,2251799813685250,2251799813816320,2251799813718016,3377699720527880,2251799814209536,3377699720528000,3377699720658944,2251799813685264,3377699720560640,3377699720527936,3377699720593408,3377699721052160,3377699720531968,2251799813718016,3377699720527888,2251799813687296,2251799814209536,3377699720528128,2251799813689344,2251799813685256,2251799813689344,3377699720560640,2251799813947392,2251799814209536,3377699720529920,3377699720527936,3377699720560640,3377699720528128,2251799813685252,3377699720527873,2251799813685376,3377699720790016,2251799813685760,3377699720536064,2251799813685504,3377699720527873,3377699720528896,3377699720531968,3377699720593408,3377699720536064,3377699720528000,3377699720527904,2251799813685250,3377699720536064,3377699720528128,2251799813689344,3377699720527888,2251799813685256,2251799813816320,3377699720527876,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    //  uint64_t data1[228]={2251799813718016,2251799813685280,2251799813693440,2251799813701632,2251799813685504,3377699720527936,3377699720527873,2251799813718016,3377699720528000,3377699720528384,2251799813693440,3377699720527873,2251799814209536,3377699720527873,2251799813687296,2251799813689344,3377699720527876,2251799813685312,3377699720528000,2251799813685280,3377699720527873,2251799813685264,2251799813750784,2251799813718016,3377699720528384,2251799813685312,2251799813685760,3377699720528000,2251799813685249,2251799813685252,2251799813685249,2251799813685250,3377699721052160,2251799814209536,2251799813685249,2251799813687296,2251799813947392,2251799813816320,2251799813685376,2251799813685312,2251799813750784,2251799813693440,2251799813685760,3377699720527888,3377699720528000,2251799813686272,2251799813718016,3377699720529920,2251799814209536,3377699720593408,2251799813685249,2251799813685256,2251799813685504,3377699720658944,2251799813685280,3377699720593408,2251799813750784,3377699720790016,2251799813947392,2251799813718016,2251799813947392,3377699720528384,2251799813685312,2251799813685312,3377699720527888,2251799813685280,3377699720528128,3377699720527876,2251799813685249,3377699720536064,3377699720544256,2251799813686272,2251799813685504,3377699720527904,3377699720658944,2251799813718016,3377699720528896,3377699720529920,2251799813686272,2251799813687296,3377699720528128,3377699720790016,2251799813689344,2251799813689344,2251799813689344,2251799813686272,2251799813685280,3377699720790016,3377699720528384,2251799813947392,2251799813685504,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    //  uint64_t data2[228]={3377699720527888,3377699720527888,2251799813816320,3377699720790016,2251799813816320,2251799813685280,3377699720527904,2251799814209536,3377699720658944,2251799814209536,2251799813750784,3377699720790016,2251799813685249,2251799813750784,3377699720790016,3377699720527904,2251799813687296,2251799813687296,2251799813718016,3377699720790016,3377699720536064,3377699720658944,2251799813685249,3377699720790016,2251799813686272,2251799813685250,3377699720593408,2251799813718016,2251799813685376,3377699720790016,2251799813685280,3377699720531968,2251799813685504,3377699720560640,3377699720528896,2251799813685280,3377699720528128,3377699720560640,2251799813947392,2251799813685249,2251799813718016,3377699720527873,2251799813685376,3377699720528000,3377699720528384,2251799813947392,2251799813685280,3377699720528000,2251799813685760,3377699720527876,2251799813750784,3377699720527936,2251799813689344,3377699720560640,3377699720527888,3377699720527936,2251799813685280,2251799813685264,3377699720560640,3377699720528896,2251799813816320,2251799813701632,2251799813693440,2251799813816320,3377699720531968,3377699720527880,2251799813689344,3377699720527936,3377699720529920,3377699720527936,3377699720536064,3377699720658944,3377699720527936,3377699720527874,2251799813686272,3377699720536064,2251799814209536,2251799813685256,2251799813693440,3377699720528128,3377699720527873,3377699720527880,2251799814209536,3377699720528896,3377699720593408,3377699720658944,3377699720527888,2251799813816320,3377699720528896,2251799814209536,3377699720528000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    // uf20-031
    //  uint64_t data0[228]={2251799813693440,2251799813750784,2251799813685256,2251799813685312,3377699720536064,3377699720527874,3377699720528128,2251799813947392,2251799813693440,3377699720528000,2251799813685312,3377699720528384,2251799813750784,2251799813685312,3377699720529920,2251799813685504,3377699720528896,3377699720544256,3377699720527876,2251799813685280,2251799813750784,2251799813685252,3377699720528000,2251799814209536,3377699720528000,2251799813685249,2251799813685256,2251799813693440,3377699720790016,2251799813685256,3377699720528896,3377699720528896,2251799813947392,2251799813701632,2251799814209536,2251799813947392,3377699720527876,2251799813693440,2251799813701632,3377699720528896,3377699720527904,3377699720527888,2251799813685256,3377699720528384,2251799813750784,3377699720527876,3377699720528000,2251799813687296,3377699721052160,2251799813947392,2251799813685250,3377699720790016,3377699720527936,3377699720527936,2251799813816320,3377699720528896,2251799813685760,3377699720560640,3377699720527880,2251799813685252,2251799813685252,3377699720560640,2251799813685312,3377699720790016,3377699720527880,2251799813687296,3377699720528000,3377699720658944,3377699720527880,2251799813686272,2251799813685280,3377699720528384,2251799813685250,3377699720527876,2251799814209536,2251799814209536,3377699720527880,3377699720529920,2251799813718016,3377699720528128,2251799813685264,2251799813689344,3377699720528128,3377699720527936,2251799813686272,2251799813947392,2251799813685280,2251799813685264,3377699720790016,2251799813816320,3377699720529920,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    //  uint64_t data1[228]={2251799813685376,2251799813816320,3377699720527888,3377699720531968,3377699720527873,2251799814209536,2251799813701632,2251799813816320,2251799813685250,2251799813685504,3377699720658944,2251799813689344,2251799813687296,2251799813685264,2251799813685280,2251799813685250,3377699720527876,2251799813685264,2251799813685256,2251799813685760,2251799813685280,2251799813685312,3377699720527904,2251799813685504,2251799814209536,3377699720528128,3377699720528000,3377699720544256,2251799813685252,2251799814209536,3377699720527873,3377699720544256,2251799813718016,2251799813685249,2251799813685249,3377699720527876,3377699721052160,2251799813685256,2251799813693440,3377699720529920,2251799813685264,2251799813689344,2251799814209536,3377699720544256,2251799813689344,2251799813685760,3377699720527880,2251799813685256,2251799813685256,3377699720527876,2251799814209536,3377699720593408,2251799813685280,3377699720527904,2251799813947392,2251799813689344,2251799813693440,3377699720527876,3377699720528000,3377699720790016,3377699720593408,2251799813685252,2251799813693440,3377699720527876,3377699720528384,2251799813685280,2251799813693440,2251799813685256,3377699720658944,3377699720527904,3377699720658944,2251799813816320,3377699720593408,2251799813816320,2251799813685280,2251799813685504,2251799813718016,3377699720528384,3377699720529920,2251799814209536,3377699720531968,2251799813685760,2251799813685760,2251799813947392,2251799813947392,3377699720527880,2251799813947392,2251799813685376,3377699720527888,2251799813685249,3377699720560640,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    //  uint64_t data2[228]={3377699720527904,2251799813689344,2251799813685249,2251799813685249,2251799813685250,2251799813685264,2251799813718016,2251799813701632,2251799813685504,3377699720560640,2251799813685250,3377699720544256,3377699720527936,2251799813685256,3377699720528000,3377699720527873,3377699720593408,2251799813685249,2251799813701632,2251799814209536,3377699720560640,2251799813686272,3377699720527880,3377699720527880,3377699720529920,3377699720536064,3377699720560640,2251799813687296,3377699720527904,3377699720560640,3377699720658944,3377699720527876,2251799813685249,3377699720527888,2251799813685256,3377699720593408,2251799813816320,2251799813701632,3377699720593408,3377699720527888,3377699720658944,2251799813816320,3377699720528384,3377699720527936,3377699720527876,3377699720560640,3377699720527888,3377699720536064,3377699720531968,2251799813685376,2251799813685312,2251799813685250,2251799814209536,3377699720560640,2251799813689344,2251799813685760,3377699720527876,2251799813685504,2251799813685312,2251799813816320,2251799813685250,2251799813693440,3377699720527904,3377699720527880,2251799813685252,2251799813685504,2251799813816320,3377699720528128,2251799813685312,3377699720527876,3377699720528896,2251799813685249,2251799813686272,2251799813685249,3377699720560640,2251799813686272,2251799813947392,2251799813947392,2251799813816320,2251799813685252,2251799813685250,3377699720544256,3377699720790016,3377699720527880,2251799813685252,2251799813816320,2251799813687296,3377699720790016,3377699720527874,3377699720527904,2251799813947392,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    // uf50-01
    //  uint64_t data0[228]={2251799813685252,2251799813685252,2533274790395904,3377699720528000,2251799814733824,3377734080266240,3377699787636736,3377699720544256,3377699720527904,3377708310462464,3377699720527874,3377699720527874,2251804108652544,3386495813550080,3940649673949184,2251834173423616,3377699754082304,3377699720544256,3377699728916480,2322168557862912,2814749767106560,3377701868011520,2251808403619840,3377699720527936,2260595906707456,3377699720527936,3377699720527876,3377700794269696,2251799880794112,3377768440004608,3377699721052160,2269391999729664,2251808403619840,2251799815782400,2251799813750784,2251799830462464,3377699720527876,2251799847239680,2251799947902976,2251799814733824,2251799813750784,3378799232155648,3377699737305088,2252074691592192,3940649673949184,3377699787636736,3395291906572288,3377708310462464,2251799813685249,3377699720658944,3377699787636736,2251799813685256,2256197860196352,2251868533161984,2251799813685504,3377704015495168,3377699720527880,2251799813685252,2251816993554432,3377699720527936,3377700257398784,2251816993554432,3377716900397056,2251799813685249,3377699787636736,2251868533161984,3940649673949184,2252899325313024,2251799813685249,2251799813687296,2251799822073856,3377699720529920,2251799813685280,2251799813685250,3377699720527873,2251799813685312,2252899325313024,3377699720531968,2251799813685252,3377704015495168,3377699720528128,2256197860196352,2252349569499136,3377700257398784,3377699720790016,2251799813718016,3377837159481344,2251799813685256,2392537302040576,3395291906572288,3377699720528128,2251799813685249,2251799813689344,2256197860196352,2251799880794112,3377699720527936,3377699720527936,2251799830462464,3377716900397056,2814749767106560,2251799814733824,2251799813685376,2251799813718016,2251937252638720,3377699720527888,3377699720528000,2251799814733824,3377699721052160,2251800082120704,2251799813685312,2392537302040576,3518437208883200,2251808403619840,2251799813693440,2286984185774080,3377734080266240,3377699720529920,2251799813685312,3377699720528128,3659174697238528,3377699722625024,3377708310462464,3377699722625024,2251799830462464,2251799847239680,3377699720544256,2251799813685249,2251799813693440,2251799813685504,2251799813816320,2251799813718016,3377700794269696,3377699720528896,2251799813689344,2251799813685760,2251799813685256,2251799830462464,2252349569499136,3377768440004608,2251799880794112,3377708310462464,3377699720527876,2814749767106560,3377699720593408,2533274790395904,3377699720544256,2251799815782400,2251799813685504,3377699754082304,3377699787636736,2251799813685312,2286984185774080,2252349569499136,2260595906707456,2251799813685252,2392537302040576,2251799830462464,2251799815782400,2251800887427072,2251799813686272,3377699724722176,3377699724722176,2251868533161984,2251799813947392,2251799815782400,2251799813685280,3377699720658944,3382097767038976,2251799813689344,2251816993554432,3377701868011520,3377699720527904,3377699787636736,3377699737305088,2256197860196352,2251799813685280,2251937252638720,3378249476341760,3377768440004608,3377974598434816,2252074691592192,2251799813816320,2252349569499136,3377768440004608,2251799813689344,3377699720527874,3377699720528000,3377699720527873,2251799814209536,3379898743783424,3377699988963328,2251799814209536,3377699724722176,3377837159481344,2251799813685504,3377699720528896,2252899325313024,3377699720527888,3386495813550080,3377837159481344,3412884092616704,2251799813816320,3377837159481344,2251801961168896,3377700794269696,2251799813816320,3377699854745600,2251799813718016,2251800082120704,3659174697238528,3377699720536064,3377700257398784,2251799822073856,3377699720527880,2251800350556160,3386495813550080,3377837159481344,2251799813686272,0,0,0,0,0,0,0,0,0,0};
    //  uint64_t data1[228]={3377734080266240,2253998836940800,2322168557862912,2252349569499136,2251800887427072,2251799815782400,3377837159481344,2251799813816320,3377699720527936,2251799813685312,3377699720536064,3448068464705536,2251816993554432,3378249476341760,3377734080266240,2251799813685252,2251800082120704,3377699988963328,2251799813686272,2251799847239680,2251804108652544,3377699720527904,3377768440004608,2251799947902976,3412884092616704,3377699722625024,3377974598434816,3412884092616704,3377701868011520,2814749767106560,3377699720527888,2251799822073856,2251799817879552,3377699721576448,3940649673949184,2251799822073856,3377716900397056,3448068464705536,2269391999729664,2251799813685280,2251799813701632,3377699720527874,3377734080266240,2251799813685252,3377699721052160,3377700794269696,2251799813701632,3940649673949184,2392537302040576,2251816993554432,2251799822073856,2251804108652544,2251799822073856,3377700794269696,2251937252638720,2251799813718016,2251816993554432,2251799814733824,2251834173423616,2256197860196352,3377699720536064,2251799822073856,2253998836940800,2251799813701632,3659174697238528,3659174697238528,2286984185774080,3377699721052160,3377699724722176,2251800350556160,3377699988963328,3377699720527888,2251799813685250,2533274790395904,2814749767106560,2814749767106560,3382097767038976,3377699720544256,2251799813686272,3518437208883200,3377699724722176,3448068464705536,3377699720560640,3377699720790016,2251808403619840,2260595906707456,2269391999729664,2251799813693440,3377716900397056,2251799813689344,3379898743783424,2251799813701632,2260595906707456,2251868533161984,2251800082120704,3377699720527880,3377699720528384,3377699721052160,2251799813685264,3377699728916480,2251799847239680,3395291906572288,3377704015495168,3377699720527904,3377699721576448,3377837159481344,3377704015495168,3378249476341760,2251799813685504,3379898743783424,3377699720528000,2251937252638720,3659174697238528,2286984185774080,3377699720527880,2251799813687296,2251799813816320,3412884092616704,2251799813685376,2253998836940800,2251799813701632,2252899325313024,2251799847239680,2269391999729664,3377701868011520,3377699754082304,3412884092616704,2251800887427072,2251799815782400,3377699754082304,2251801961168896,2533274790395904,3377699720528128,2251800350556160,3377699720527880,3377699720527876,2814749767106560,3377699720527880,3377699721052160,3377699722625024,3377699720536064,2251800887427072,3377699720527874,2251800082120704,3377699720529920,2251816993554432,2251799817879552,3377704015495168,3377699988963328,2814749767106560,3412884092616704,2251868533161984,3377734080266240,3412884092616704,3377734080266240,3377699720528128,2251799813685256,3377768440004608,2251799813750784,2392537302040576,3377708310462464,2392537302040576,2251799813685249,3377699787636736,3377704015495168,2251801961168896,2251799814209536,3377699722625024,3377708310462464,2286984185774080,3377974598434816,2252074691592192,3377974598434816,2251799813750784,3377699787636736,3659174697238528,3377699720528896,2251937252638720,2251799813693440,3377699988963328,2251799947902976,3377699720536064,3940649673949184,2253998836940800,3377700794269696,2253998836940800,2251799813685252,3377699724722176,2269391999729664,3377699720528896,3377699720528896,2251799814733824,3395291906572288,2251800350556160,3518437208883200,2251799813816320,2251799813685249,3378799232155648,2251800350556160,2251799813685280,3518437208883200,2251799813685760,3412884092616704,3412884092616704,3378249476341760,3377699720527874,2251937252638720,2251799814733824,3377699720544256,3377708310462464,3377699722625024,3377704015495168,3377699722625024,2392537302040576,2251834173423616,3377699720529920,3377699720527876,3377704015495168,0,0,0,0,0,0,0,0,0,0};
    //  uint64_t data2[228]={3377699720527936,2392537302040576,2252899325313024,3377699720593408,2252074691592192,3659174697238528,3377699720536064,3377699720527904,2256197860196352,3377699724722176,2251799813689344,2253998836940800,3377699720527876,3659174697238528,3377700794269696,2251868533161984,3382097767038976,2269391999729664,3377699720658944,3377699720527904,2251799813685760,3377699720560640,3378799232155648,2251799813750784,3377699720790016,2392537302040576,3377708310462464,2256197860196352,3377699724722176,2251799813816320,3377699720528896,3377699720527904,2251799813693440,3377699721052160,3377699728916480,2251799880794112,3377699721576448,2251834173423616,3659174697238528,3377699720529920,2252074691592192,2251799813693440,2251799817879552,2252349569499136,3377716900397056,2252074691592192,2252349569499136,3377716900397056,3377699720529920,2251800350556160,2251799830462464,2251799813687296,2251868533161984,2260595906707456,3377699720536064,3377708310462464,2251799813685264,2251799813947392,2251800082120704,3377734080266240,3378799232155648,2251799813685312,3377699720527904,3377974598434816,2251799813718016,2251799813685760,2251799813685252,3377708310462464,3377699854745600,2251799814209536,2251868533161984,2260595906707456,3518437208883200,2256197860196352,3377699728916480,2260595906707456,3377699720527880,2251799813686272,3377699724722176,3378799232155648,2533274790395904,3377699720527873,2251800082120704,3377699720527876,3518437208883200,3377699720536064,2251799813687296,2251800887427072,2251799813685249,3377699720790016,2251799813685312,3377699720528000,2251799813693440,2251800887427072,3448068464705536,3377699720593408,3377716900397056,3377699720593408,2253998836940800,2251799813685264,3377699720527874,2251799814733824,3659174697238528,3377699720560640,3377768440004608,3377700794269696,3377699720536064,2251799813685264,3377700794269696,2251799815782400,3377699754082304,3377704015495168,3412884092616704,3377699737305088,3377699720658944,2251800887427072,3377699720536064,2251799813718016,3377699720527936,2251799815782400,3377837159481344,3448068464705536,3377701868011520,2251799814733824,2251799813686272,2251799830462464,3377699737305088,3377700257398784,3377699720529920,2251816993554432,2251799814733824,2251799814733824,3378799232155648,3377699720790016,3377699720527904,2251799815782400,2251799813816320,3377699720528128,3412884092616704,2251800082120704,3377699720527876,3377699721052160,2251799847239680,3377837159481344,2252899325313024,2256197860196352,2533274790395904,3518437208883200,3377716900397056,3377768440004608,2256197860196352,2251799813685376,2251799822073856,3377699720544256,2251799813718016,3382097767038976,3386495813550080,2251799813685312,2251799815782400,3377699720593408,2251799947902976,2252074691592192,2251799817879552,3377699720536064,2251799813685280,2251799847239680,2286984185774080,3377699787636736,3659174697238528,3377699720527876,2256197860196352,2251799813685504,2251799813718016,2251799813701632,3377708310462464,3377699720527888,3377699720536064,3448068464705536,3377699720593408,3377734080266240,3377699720527873,2251799813718016,3377699720544256,3377699720658944,3377704015495168,3377704015495168,2251799815782400,2251800887427072,3377699754082304,3659174697238528,2256197860196352,3377700257398784,2251816993554432,2251799813693440,2251800082120704,2251799817879552,2251800082120704,3377699754082304,2251799813685312,2252899325313024,2251799813701632,2322168557862912,2251801961168896,3377699720529920,3377699720536064,3659174697238528,3377699787636736,3377699720536064,3377699720529920,3377699720527888,2251799813687296,3377699721052160,3377699737305088,2251799817879552,3377699720528128,2251816993554432,2251799814733824,3659174697238528,0,0,0,0,0,0,0,0,0,0};
    //  test
    //  uint64_t data0[228]={3377699720527880,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    //  uint64_t data1[228]={3377699720658944,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    //  uint64_t data2[228]={3377699720790016,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

    SerialUSB.println("Starting Multi_run====================");
    SerialUSB.println("Write_Scan_chain_0");
    // uint64_t no_data0[228],no_data1[228],no_data2[228];
    Scan_chain_data_program(0, data0, data1, data2, 0);
    SerialUSB.println("Continue0");
    writeReg(CONTROL_REGS + PC_CONTINUE * 4, 0x00000001);
    Read_data();
    SerialUSB.println("Write_Scan_chain_1");
    Scan_chain_data_program(0, data0, data1, data2, 0);
    SerialUSB.println("Continue1");
    writeReg(CONTROL_REGS + PC_CONTINUE * 4, 0x00000001);
    Read_data();
    SerialUSB.println("Write_Scan_chain_2");
    Scan_chain_data_program(0, data0, data1, data2, 0);
    SerialUSB.println("Continue2");
    writeReg(CONTROL_REGS + PC_CONTINUE * 4, 0x00000001);
    Read_data();
    SerialUSB.println("Write_Scan_chain_3");
    Scan_chain_data_program(0, data0, data1, data2, 0);
    SerialUSB.println("Continue2");
    writeReg(CONTROL_REGS + PC_CONTINUE * 4, 0x00000001);
    Read_data();
    SerialUSB.println("Write_Scan_chain_4");
    Scan_chain_data_program(0, data0, data1, data2, 0);
    SerialUSB.println("Continue2");
    writeReg(CONTROL_REGS + PC_CONTINUE * 4, 0x00000001);
    Read_data();
}
void DAEDALUS::General_setup_for_dummy(bool die, uint8_t analog_counter, uint32_t timeout_value, bool mode)
{
    if (die)
    {
        EXPIO.writePCA9671(Register_address_2, 0b11111111, 0x00); // die2
    }
    else
    {
        EXPIO.writePCA9671(Register_address_2, 0b11011111, 0x00); // die1
    }

    // instruction memory setup
    if (mode)
    {
        // Latching mode_OLD
        writeReg(INSTRUCTION_REGS + 0 * 4, 0x40604042); // Reset(0x42)           ==> Reset_REG(0: reset)  (0x080_XX)
        writeReg(INSTRUCTION_REGS + 1 * 4, 0x40604042); //
        writeReg(INSTRUCTION_REGS + 2 * 4, 0x60604042); // Pause
        writeReg(INSTRUCTION_REGS + 3 * 4, 0x40604042); // Reset(0x42)           ==> release_Reset_REG    (0x088_XX)
        writeReg(INSTRUCTION_REGS + 4 * 4, 0x40604042); // Reset(0x42)           ==> release_Reset_REG    (0x088_XX)
        writeReg(INSTRUCTION_REGS + 5 * 4, 0x406040c2); // Release reset (0x82)  ==> Reset_SMPL(0: reset) (0x088_XX)
        writeReg(INSTRUCTION_REGS + 6 * 4, 0xc0004142); // Load hard info (Hard info memeory:0xc0004142) (LFSR: 0xc0084142)
        writeReg(INSTRUCTION_REGS + 7 * 4, 0x406041ca); // PHI on (0x8a)         ==> release_Reset_SMPL   (0x08c_XX)
        writeReg(INSTRUCTION_REGS + 8 * 4, 0x40604cc2); // PHI oFF (0x82)        ==>
        writeReg(INSTRUCTION_REGS + 9 * 4, 0x40005c83); // Ib&RUN (0x83)            ==>

        writeReg(INSTRUCTION_REGS + 10 * 4, 0x80185c83); // Wait for done 100_0000000000_   //Jump to instruction 11

        writeReg(INSTRUCTION_REGS + 11 * 4, 0x60005c82); // Pause 011_0000000000_000_11_0_0000_0000_0000

        writeReg(INSTRUCTION_REGS + 12 * 4, 0x20184002); // Jump
        writeReg(INSTRUCTION_REGS + 13 * 4, 0xa0104083); // TERM 011_0000000000_000_11_0_0000_0000_0000

        // //Latching mode
        // writeReg(INSTRUCTION_REGS+0*4,0x40600042);  //Reset(0x42)           ==> Reset_REG(0: reset)  (0x080_XX)
        // writeReg(INSTRUCTION_REGS+1*4,0x40600042);  //
        // writeReg(INSTRUCTION_REGS+2*4,0x60600042);  //Pause
        // writeReg(INSTRUCTION_REGS+3*4,0x40600042);  //Reset(0x42)           ==> release_Reset_REG    (0x088_XX)
        // writeReg(INSTRUCTION_REGS+4*4,0x40600042);  //Reset(0x42)           ==> release_Reset_REG    (0x088_XX)
        // writeReg(INSTRUCTION_REGS+5*4,0x406000c2);  //Release reset (0x82)  ==> Reset_SMPL(0: reset) (0x088_XX)
        // writeReg(INSTRUCTION_REGS+6*4,0xc0000142);  //Load hard info (Hard info memeory:0xc0004142) (LFSR: 0xc0084142)
        // writeReg(INSTRUCTION_REGS+7*4,0x406001ca);  //PHI on (0x8a)         ==> release_Reset_SMPL   (0x08c_XX)
        // writeReg(INSTRUCTION_REGS+8*4,0x40600cc2);  //PHI oFF (0x82)        ==>
        // writeReg(INSTRUCTION_REGS+9*4,0x40001c83);  //Ib&RUN (0x83)            ==>

        // writeReg(INSTRUCTION_REGS+10*4, 0x80181c83);  //Wait for done 100_0000000000_   //Jump to instruction 11

        // writeReg(INSTRUCTION_REGS+11*4,0x60001c82);  //Pause 011_0000000000_000_11_0_0000_0000_0000

        // writeReg(INSTRUCTION_REGS+12*4,0x20180002);  // Jump
        // writeReg(INSTRUCTION_REGS+13*4,0xa0100083);  //TERM 011_0000000000_000_11_0_0000_0000_0000
    }
    else
    {
        //     //Oscillating mode
        writeReg(INSTRUCTION_REGS + 0 * 4, 0x40608042); // Reset(0x42)           ==> Reset_REG(0: reset)  (0x080_XX)
        writeReg(INSTRUCTION_REGS + 1 * 4, 0x40608042); //
        writeReg(INSTRUCTION_REGS + 2 * 4, 0x60608042); // Pause
        writeReg(INSTRUCTION_REGS + 3 * 4, 0x40608042); // Reset(0x42)           ==> release_Reset_REG    (0x088_XX)
        writeReg(INSTRUCTION_REGS + 4 * 4, 0x40608042); // Reset(0x42)           ==> release_Reset_REG    (0x088_XX)
        writeReg(INSTRUCTION_REGS + 5 * 4, 0x406080c2); // Release reset (0x82)  ==> Reset_SMPL(0: reset) (0x088_XX)
        writeReg(INSTRUCTION_REGS + 6 * 4, 0xc0008142); // Load hard info (Hard info memeory:0xc0004142) (LFSR: 0xc0084142)
        writeReg(INSTRUCTION_REGS + 7 * 4, 0x406081ca); // PHI on (0x8a)         ==> release_Reset_SMPL   (0x08c_XX)
        writeReg(INSTRUCTION_REGS + 8 * 4, 0x40608cc2); // PHI oFF (0x82)        ==>
        writeReg(INSTRUCTION_REGS + 9 * 4, 0x40009ce1); // Ib on RUN (0x83)            ==>

        writeReg(INSTRUCTION_REGS + 10 * 4, 0x80189ce1); // Wait for done 100_0000000000_   //Jump to instruction 11

        writeReg(INSTRUCTION_REGS + 11 * 4, 0x60009ce2); // Pause 011_0000000000_000_11_0_0000_0000_0000

        writeReg(INSTRUCTION_REGS + 12 * 4, 0x20188002); // Jump
        writeReg(INSTRUCTION_REGS + 13 * 4, 0xa0108083); // TERM 011_0000000000_000_11_0_0000_0000_0000
    }

    // Digital system setup
    writeReg(CONTROL_REGS + CTRL_EN * 4, 0x00000000);            // Enable control
    writeReg(CONTROL_REGS + INSTR_SRC_SEL * 4, 0x00000001);      // Select instruction source
    writeReg(CONTROL_REGS + DIG_TRIG_CYC * 4, 0xffffffff);       // Set digital trigger counters
    writeReg(CONTROL_REGS + RXO_TIMEOUT_CYC * 4, timeout_value); // Set RXO timeout cycles
    writeReg(CONTROL_REGS + MAX_RERSTART * 4, 0x00000002);       // Set timeout number for several tries
    // Hard info initialization
    writeReg(HARD_INFO_REGS + Hard_info_init_0 * 4, 0xffffffff);
    writeReg(HARD_INFO_REGS + Hard_info_init_1 * 4, 0xffffffff);
    // Hard info enable
    writeReg(HARD_INFO_REGS + Hard_info_en_0 * 4, 0xffffffff); // for 20variables: 0x003fffff
    writeReg(HARD_INFO_REGS + Hard_info_en_1 * 4, 0xffffffff);
    // Hard info configurations
    writeReg(CONTROL_REGS + HARD_INFO_CONF * 4, 0x0); // Set for using hard info in the memory| If using LFSR, then should be 0x1
    // Dummy setup
    writeReg(CONTROL_REGS + DUM_RXO_CONF * 4, 0x001eff); // CN
    writeReg(CONTROL_REGS + DUM_RXO_CONF * 4, 0x001eff); // IN
    writeReg(CONTROL_REGS + DUM_RXO_CONF * 4, 0x001eff); // Reset
    writeReg(CONTROL_REGS + DUM_RXO_CONF * 4, 0x003eff); // RUN
    writeReg(CONTROL_REGS + DUM_RXO_CONF * 4, 0x007eff); // Release reset

    writeReg(CONTROL_REGS + DUM_RXO_CONF * 4, 0x006eff); // Ib  6 5 3| 0 1 2 4 7==> 1 2 4
    delayMicroseconds(16);
    // DLL setup
    writeReg(CONTROL_REGS + SMPL_CONF * 4, 0b10000000 | analog_counter); // Analog trigger and counter| 7:digital_trigger/analog_trigger, 6:CLK_Mask, 5~0: Analog5 counter
    writeReg(CONTROL_REGS + DLL_CONF * 4, 0x1);                          // 2:Reset, 1~0:DLL input select (RXO_dummy/external)
    writeReg(CONTROL_REGS + DLL_CONF * 4, 0x1);
    writeReg(CONTROL_REGS + DLL_CONF * 4, 0x1);
    writeReg(CONTROL_REGS + DLL_CONF * 4, 0x5);

    // delayMicroseconds(10000);

    // //IMF Reset and disable reset
    writeReg(CONTROL_REGS + IMF_CONF * 4, 0x0);
    writeReg(CONTROL_REGS + IMF_CONF * 4, 0x0);
    writeReg(CONTROL_REGS + IMF_CONF * 4, 0x0);
    writeReg(CONTROL_REGS + IMF_CONF * 4, 0x1);

    // Start instuction memory
    writeReg(CONTROL_REGS + CTRL_EN * 4, 0x1); // Enable control
    SerialUSB.println("Wait for DLL to stabilize.");
    delayMicroseconds(500);

    // //Readback the registers
    // uint32_t reg_data_chip0 = 0;
    // reg_data_chip0 = readReg(INSTRUCTION_REGS+0*4);
    // SerialUSB.println("Instuction meomory readback_1: "+String(reg_data_chip0, HEX)+" ");
    // reg_data_chip0 = readReg(INSTRUCTION_REGS+1*4);
    // SerialUSB.println("Instuction meomory readback_0: "+String(reg_data_chip0, HEX)+" ");
    // reg_data_chip0 = readReg(CONTROL_REGS+STATUS_CUR_PC*4);
    // SerialUSB.println("Current PC: "+String(reg_data_chip0, HEX)+" ");
    // //Digitla system setup
    // reg_data_chip0 = readReg(CONTROL_REGS+CTRL_EN*4);
    // SerialUSB.println("Enable control: "+String(reg_data_chip0, HEX)+" ");
    // reg_data_chip0 = readReg(CONTROL_REGS+INSTR_SRC_SEL*4);
    // SerialUSB.println("instruction source: "+String(reg_data_chip0, HEX)+" ");
    // reg_data_chip0 = readReg(CONTROL_REGS+DIG_TRIG_CYC*4);
    // SerialUSB.println("Digital trigger counter: "+String(reg_data_chip0, HEX)+" ");
    // reg_data_chip0 = readReg(CONTROL_REGS+RXO_TIMEOUT_CYC*4);
    // SerialUSB.println("digital trigger cycles: "+String(reg_data_chip0, HEX)+" ");
    // reg_data_chip0 = readReg(CONTROL_REGS+MAX_RERSTART*4);
    // SerialUSB.println("timeout number: "+String(reg_data_chip0, HEX)+" ");
    // //Hard info initialization
    // reg_data_chip0 = readReg(HARD_INFO_REGS+Hard_info_init_0*4);
    // SerialUSB.println("Hard info init_0: "+String(reg_data_chip0, HEX)+" ");
    // reg_data_chip0 = readReg(HARD_INFO_REGS+Hard_info_init_1*4);
    // SerialUSB.println("Hard info init_1: "+String(reg_data_chip0, HEX)+" ");
    // //Hard info enable
    // reg_data_chip0 = readReg(HARD_INFO_REGS+Hard_info_en_0*4);
    // SerialUSB.println("Hard info enable_0: "+String(reg_data_chip0, HEX)+" ");
    // reg_data_chip0 = readReg(HARD_INFO_REGS+Hard_info_en_1*4);
    // SerialUSB.println("Hard info enable_1: "+String(reg_data_chip0, HEX)+" ");
    // //Hard info configurations
    // reg_data_chip0 = readReg(CONTROL_REGS+HARD_INFO_CONF*4);
    // SerialUSB.println("Hard info configurations: "+String(reg_data_chip0, HEX)+" ");
    // //Dummy setup
    // reg_data_chip0 = readReg(CONTROL_REGS+DUM_RXO_CONF*4);
    // SerialUSB.println("Dummy setup: "+String(reg_data_chip0, HEX)+" ");
    // //DLL setup
    // reg_data_chip0 = readReg(CONTROL_REGS+SMPL_CONF*4);
    // SerialUSB.println("SMPL setup: "+String(reg_data_chip0, HEX)+" ");
    // reg_data_chip0 = readReg(CONTROL_REGS+DLL_CONF*4);
    // SerialUSB.println("DLL setup: "+String(reg_data_chip0, HEX)+" ");
    // //IMF Reset and disable reset
    // reg_data_chip0 = readReg(CONTROL_REGS+IMF_CONF*4);
    // SerialUSB.println("IMF setup: "+String(reg_data_chip0, HEX)+" ");
    // //Start instuction memory
    // reg_data_chip0 = readReg(CONTROL_REGS+ANA_CTRLS_CSR*4);
    // SerialUSB.println("Instuction meomory start: "+String(reg_data_chip0, HEX)+" ");
    // reg_data_chip0 = readReg(CONTROL_REGS+STATUS_CUR_PC*4);
    // SerialUSB.println("Current PC: "+String(reg_data_chip0, HEX)+" ");
}

#include <SD.h>

// Returns how many 3-digit, purely numeric subfolders exist at the root of the SD card.
int countNumericFoldersAtRoot()
{
    File root = SD.open("/");
    if (!root)
    {
        SerialUSB.println("Failed to open root directory.");
        return 0;
    }

    if (!root.isDirectory())
    {
        SerialUSB.println("Root is not a directory?!");
        root.close();
        return 0;
    }

    int folderCount = 0;
    File entry;

    // Keep reading until no more files/folders in root
    while (true)
    {
        entry = root.openNextFile();
        if (!entry)
        {
            // No more files/folders
            break;
        }

        // If this is a *folder* at root
        if (entry.isDirectory())
        {
            // For example, entry.name() might be "000", "001", ...
            String folderName = entry.name();
            // If folderName is exactly 3 chars and all digits:
            if (folderName.length() == 3 &&
                isDigit(folderName[0]) &&
                isDigit(folderName[1]) &&
                isDigit(folderName[2]))
            {
                folderCount++;
            }
        }
        entry.close();
    }

    root.close();
    return folderCount;
}

// Returns how many 3-digit, purely numeric subfolders exist inside baseFolder on the SD card.
int countProblemFolders(const char *baseFolder)
{
    File dir = SD.open(baseFolder); // Open the parent directory
    if (!dir)
    {
        SerialUSB.println("Failed to open directory: " + String(baseFolder));
        return 0;
    }

    if (!dir.isDirectory())
    {
        SerialUSB.println(String(baseFolder) + " is not a directory.");
        dir.close();
        return 0;
    }

    int folderCount = 0;
    File entry;
    // Keep reading until no more files or subfolders in the parent directory
    while (true)
    {
        entry = dir.openNextFile();
        if (!entry)
        {
            // no more files/subfolders
            break;
        }

        // Check if this is a directory
        if (entry.isDirectory())
        {
            // e.g., entry.name() might be "000", "001", ...
            String folderName = entry.name();
            // If folderName is exactly 3 chars and all digits:
            if (folderName.length() == 3 &&
                isDigit(folderName[0]) &&
                isDigit(folderName[1]) &&
                isDigit(folderName[2]))
            {
                folderCount++;
            }
        }
        entry.close();
    }
    dir.close();

    return folderCount;
}

void DAEDALUS::Scan_chain_data_program(bool die, uint64_t *data0, uint64_t *data1, uint64_t *data2, bool Read_enable)
{
    // uint32_t counter=0;
    // bool Read_enable=1;
    if (die == 0)
    {
        digitalWriteFast(SCAN_WRITE_EN_DIE1, HIGH);
        digitalWriteFast(SCAN_WRITE_EN_DIE2, LOW);
    }
    else
    {
        digitalWriteFast(SCAN_WRITE_EN_DIE1, LOW);
        digitalWriteFast(SCAN_WRITE_EN_DIE2, HIGH);
    }
    uint16_t counter_52 = 0;
    uint16_t counter_224 = 227;
    uint32_t delay = 1500;
    uint32_t all_memory = 52 * 228;
    bool odd_row = 1; // 0~223 rows //default is 1, because it starts from 223
    uint64_t data_mask[52];
    data_mask[0] = 0x0000000000000001;

    uint64_t read_data0[228];
    uint64_t read_data1[228];
    uint64_t read_data2[228];

    bool temp_read0 = 0;
    bool temp_read1 = 0;
    bool temp_read2 = 0;

    uint16_t correct_clauses0 = 0;
    uint16_t correct_clauses1 = 0;
    uint16_t correct_clauses2 = 0;
    int read_data0_temp = 0;
    int read_data1_temp = 0;
    int read_data2_temp = 0;
    for (uint16_t i = 1; i < 52; i++)
    {
        data_mask[i] = data_mask[i - 1] << 1;
    }
    for (uint16_t i = 0; i < 228; i++)
    {
        read_data0[i] = 0;
        read_data1[i] = 0;
        read_data2[i] = 0;
    }
    for (uint32_t counter = 0; counter < all_memory + all_memory * Read_enable; counter++)
    {
        // Write data to the scan chain
        if (counter < all_memory)
        {
            if (!odd_row)
            {

                digitalWriteFast(SCAN_CLK_IN, LOW);
                digitalWriteFast(SCAN_IN0, ((data0[counter_224] & data_mask[51 - counter_52]) && data_mask[51 - counter_52]));
                digitalWriteFast(SCAN_IN1, ((data1[counter_224] & data_mask[51 - counter_52]) && data_mask[51 - counter_52]));
                digitalWriteFast(SCAN_IN2, ((data2[counter_224] & data_mask[51 - counter_52]) && data_mask[51 - counter_52]));

                delayNanoseconds(delay);

                digitalWriteFast(SCAN_CLK_IN, HIGH);
                delayNanoseconds(delay);
            }
            else
            {

                digitalWriteFast(SCAN_CLK_IN, LOW);
                digitalWriteFast(SCAN_IN0, ((data0[counter_224] & data_mask[counter_52]) && data_mask[counter_52]));
                digitalWriteFast(SCAN_IN1, ((data1[counter_224] & data_mask[counter_52]) && data_mask[counter_52]));
                digitalWriteFast(SCAN_IN2, ((data2[counter_224] & data_mask[counter_52]) && data_mask[counter_52]));

                delayNanoseconds(delay);

                digitalWriteFast(SCAN_CLK_IN, HIGH);
                delayNanoseconds(delay);
            }
        }
        // Read data from the scan chain
        else if ((counter >= all_memory))
        {
            // if (counter == all_memory)
            // {

            // }
            if (!odd_row)
            {

                digitalWriteFast(SCAN_CLK_IN, LOW);
                temp_read0 = digitalReadFast(SCAN_OUT0);
                temp_read1 = digitalReadFast(SCAN_OUT1);
                temp_read2 = digitalReadFast(SCAN_OUT2);
                delayNanoseconds(delay);
                digitalWriteFast(SCAN_CLK_IN, HIGH);
                delayNanoseconds(delay);
                if (temp_read0)
                {
                    read_data0[counter_224] |= data_mask[51 - counter_52];
                }
                if (temp_read1)
                {
                    read_data1[counter_224] |= data_mask[51 - counter_52];
                }
                if (temp_read2)
                {
                    read_data2[counter_224] |= data_mask[51 - counter_52];
                }
            }
            else
            {

                digitalWriteFast(SCAN_CLK_IN, LOW);
                temp_read0 = digitalReadFast(SCAN_OUT0);
                temp_read1 = digitalReadFast(SCAN_OUT1);
                temp_read2 = digitalReadFast(SCAN_OUT2);
                delayNanoseconds(delay);
                digitalWriteFast(SCAN_CLK_IN, HIGH);
                delayNanoseconds(delay);
                if (temp_read0)
                {
                    read_data0[counter_224] |= data_mask[counter_52];
                }
                if (temp_read1)
                {
                    read_data1[counter_224] |= data_mask[counter_52];
                }
                if (temp_read2)
                {
                    read_data2[counter_224] |= data_mask[counter_52];
                }
            }
        }
        if (counter % 52 == 51 && counter_224 != 0 && counter < all_memory)
        {
            counter_224--;
            counter_52 = 0;
            odd_row = !odd_row;
        }
        else if (counter % 52 == 51 && counter_224 == 0 && counter < all_memory)
        {
            counter_224 = 227;
            counter_52 = 0;
            odd_row = !odd_row;
        }
        else if (counter % 52 == 51 && counter >= all_memory)
        {
            if (counter > all_memory)
            {
                correct_clauses0 = correct_clauses0 + int(read_data0[counter_224] == data0[counter_224]);
                correct_clauses1 = correct_clauses1 + int(read_data1[counter_224] == data1[counter_224]);
                correct_clauses2 = correct_clauses2 + int(read_data2[counter_224] == data2[counter_224]);

                read_data0_temp = read_data0[counter_224];
                read_data1_temp = read_data1[counter_224];
                read_data2_temp = read_data2[counter_224];
                SerialUSB.println("Read_Data0[" + String(counter_224) + "]: " + String(read_data0_temp) + " ");
                SerialUSB.println("Read_Data1[" + String(counter_224) + "]: " + String(read_data1_temp) + " ");
                SerialUSB.println("Read_Data2[" + String(counter_224) + "]: " + String(read_data2_temp) + " ");
            }
            counter_224--;
            counter_52 = 0;
            odd_row = !odd_row;
        }
        else
        {
            counter_52++;
        }
    }
    if (Read_enable)
    {
        SerialUSB.println("correct_clauses0: " + String(correct_clauses0) + " ");
        SerialUSB.println("correct_clauses1: " + String(correct_clauses1) + " ");
        SerialUSB.println("correct_clauses2: " + String(correct_clauses2) + " ");
    }
    // digitalWriteFast(SCAN_CLK_IN, HIGH);
    digitalWriteFast(SCAN_WRITE_EN_DIE1, LOW);
    digitalWriteFast(SCAN_WRITE_EN_DIE2, LOW);
}

void DAEDALUS::batchRunLoop(String batchname, String Output_batchname, uint32_t problems, uint16_t runNum, bool uf20_or50, bool die, uint32_t timeout_value)
{
    // uint32_t softInfo[24] = {0};    // Preallocate array for soft info
    // uint32_t samples[25] = {0};     // Preallocate array for output data

    uint64_t data_in0[228];
    uint64_t data_in1[228];
    uint64_t data_in2[228];

    uint32_t data_in01[228];
    uint32_t data_in11[228];
    uint32_t data_in21[228];

    uint32_t data_in02[228];
    uint32_t data_in12[228];
    uint32_t data_in22[228];

    // uint64_t data_out0[228];
    // uint64_t data_out1[228];
    // uint64_t data_out2[228];
    uint32_t how_many_runs[2] = {runNum, runNum};
    // uint32_t sampled_data[17];  //Output data// 0:how many runs,
    uint32_t sampled_data[15]; // Output data// 0:how many runs,
    // uint32_t test_results[3];
    String dataFolderStr;
    uint16_t strLen;

    dataFolderStr = batchname;
    strLen = dataFolderStr.length() + 1;
    char dataFolderChar[strLen];
    dataFolderStr.toCharArray(dataFolderChar, strLen);
    SD.mkdir(dataFolderChar);

    uint32_t restart_counter_previous = 1;
    uint32_t restart_counter_now = 1;

    // hi

    int numFolders = countNumericFoldersAtRoot();
    Serial.println("Found a total of " + String(numFolders) + " problems");

    for (uint32_t i = 0; i < numFolders; i++)
    // for (uint32_t i = 1; i < problems+1; i++)
    // Needs to be changed back
    // for (uint32_t i = 2; i < problems+1; i++)
    {

        // check if the problem folder with the correct name is in the folder
        // e.g. 000, 001, 002, 003, ..., formatted depending on the iterator value
        // Format the folder name with leading zeros

        bool readyToSolve = false;

        char folderName[4];
        snprintf(folderName, sizeof(folderName), "%03d", i);

        if (!SD.exists(folderName))
        {
            SerialUSB.println("Created The problem " + String(folderName) + " does not exist. Skipping.");
            break;
        }

        String test_problem;
        // if (uf20_or50)
        // {
        //     test_problem = "/uf20-0";
        // }
        // else
        // {
        //     test_problem = "/uf50-0";
        // }
        // String Data_Info_01;  // Concatenate file path as String
        // String Data_Info_02;  // Concatenate file path as String
        // String Data_Info_11;  // Concatenate file path as String
        // String Data_Info_12;  // Concatenate file path as String
        // String Data_Info_21;  // Concatenate file path as String
        // String Data_Info_22;  // Concatenate file path as String
        // char Data_Info_name_01[strLen];
        // char Data_Info_name_02[strLen];
        // char Data_Info_name_11[strLen];
        // char Data_Info_name_12[strLen];
        // char Data_Info_name_21[strLen];
        // char Data_Info_name_22[strLen];
        // if (uf20_or50)
        // {
        // Load data from SD card (I have changed the index from i to 0)
        // String Data_Info_01 = batchname + "/uf20-0" + String(i) + "/data_info_01.csv";  // Concatenate file path as String
        // strLen = Data_Info_01.length() + 1;                                          // Calculate length of String
        // char Data_Info_name_01[strLen];                                                  // Initialize char array
        // Data_Info_01.toCharArray(Data_Info_name_01, strLen);                              // Copy file path to char array

        // String Data_Info_02 = batchname + "/uf20-0" + String(i) + "/data_info_02.csv";  // Concatenate file path as String
        // strLen = Data_Info_02.length() + 1;                                          // Calculate length of String
        // char Data_Info_name_02[strLen];                                                  // Initialize char array
        // Data_Info_02.toCharArray(Data_Info_name_02, strLen);                              // Copy file path to char array

        // String Data_Info_11 = batchname + "/uf20-0" + String(i) + "/data_info_11.csv";  // Concatenate file path as String
        // strLen = Data_Info_11.length() + 1;                                          // Calculate length of String
        // char Data_Info_name_11[strLen];                                                  // Initialize char array
        // Data_Info_11.toCharArray(Data_Info_name_11, strLen);                              // Copy file path to char array

        // String Data_Info_12 = batchname + "/uf20-0" + String(i) + "/data_info_12.csv";  // Concatenate file path as String
        // strLen = Data_Info_12.length() + 1;                                          // Calculate length of String
        // char Data_Info_name_12[strLen];                                                  // Initialize char array
        // Data_Info_12.toCharArray(Data_Info_name_12, strLen);                              // Copy file path to char array

        // String Data_Info_21 = batchname + "/uf20-0" + String(i) + "/data_info_21.csv";  // Concatenate file path as String
        // strLen = Data_Info_21.length() + 1;                                          // Calculate length of String
        // char Data_Info_name_21[strLen];                                                  // Initialize char array
        // Data_Info_21.toCharArray(Data_Info_name_21, strLen);                              // Copy file path to char array

        // String Data_Info_22 = batchname + "/uf20-0" + String(i) + "/data_info_22.csv";  // Concatenate file path as String
        // strLen = Data_Info_22.length() + 1;                                          // Calculate length of String
        // char Data_Info_name_22[strLen];                                                  // Initialize char array
        // Data_Info_22.toCharArray(Data_Info_name_22, strLen);                              // Copy file path to char array
        // }
        // else
        // {
        //     // Load data from SD card (I have changed the index from i to 0)
        String Data_Info_01 = String(folderName) + "/data_info_01.csv"; // Concatenate file path as String
        strLen = Data_Info_01.length() + 1;                             // Calculate length of String
        char Data_Info_name_01[strLen];                                 // Initialize char array
        Data_Info_01.toCharArray(Data_Info_name_01, strLen);            // Copy file path to char array

        String Data_Info_02 = String(folderName) + "/data_info_02.csv"; // Concatenate file path as String
        strLen = Data_Info_02.length() + 1;                             // Calculate length of String
        char Data_Info_name_02[strLen];                                 // Initialize char array
        Data_Info_02.toCharArray(Data_Info_name_02, strLen);            // Copy file path to char array

        String Data_Info_11 = String(folderName) + "/data_info_11.csv"; // Concatenate file path as String
        strLen = Data_Info_11.length() + 1;                             // Calculate length of String
        char Data_Info_name_11[strLen];                                 // Initialize char array
        Data_Info_11.toCharArray(Data_Info_name_11, strLen);            // Copy file path to char array

        String Data_Info_12 = String(folderName) + "/data_info_12.csv"; // Concatenate file path as String
        strLen = Data_Info_12.length() + 1;                             // Calculate length of String
        char Data_Info_name_12[strLen];                                 // Initialize char array
        Data_Info_12.toCharArray(Data_Info_name_12, strLen);            // Copy file path to char array

        String Data_Info_21 = String(folderName) + "/data_info_21.csv"; // Concatenate file path as String
        strLen = Data_Info_21.length() + 1;                             // Calculate length of String
        char Data_Info_name_21[strLen];                                 // Initialize char array
        Data_Info_21.toCharArray(Data_Info_name_21, strLen);            // Copy file path to char array

        String Data_Info_22 = String(folderName) + "/data_info_22.csv"; // Concatenate file path as String
        strLen = Data_Info_22.length() + 1;                             // Calculate length of String
        char Data_Info_name_22[strLen];                                 // Initialize char array
        Data_Info_22.toCharArray(Data_Info_name_22, strLen);            // Copy file path to char array

        // }

        readCSV(Data_Info_name_01, data_in01, 228); // Read problems from SD card
        readCSV(Data_Info_name_02, data_in02, 228); // Read problems from SD card
        readCSV(Data_Info_name_11, data_in11, 228); // Read problems from SD card
        readCSV(Data_Info_name_12, data_in12, 228); // Read problems from SD card
        readCSV(Data_Info_name_21, data_in21, 228); // Read problems from SD card
        readCSV(Data_Info_name_22, data_in22, 228); // Read problems from SD card

        // readCSV_64(Data_Info_name_1, data_in1, 228);
        // readCSV_64(Data_Info_name_2, data_in2, 228);
        // loadSoftInfo(softInfo);                 // Load soft info onto chip
        // for debugging
        // uint32_t temp=data_in01[0];
        // uint32_t temp1=data_in02[0];

        // SerialUSB.println("data0: "+String(temp)+" ");
        // // temp=data_in1[0];
        // SerialUSB.println("data1: "+String(temp1)+" ");
        // temp=data_in01[89];
        // temp1=data_in02[89];
        // SerialUSB.println("data0: "+String(temp)+" ");
        // // temp=data_in1[0];
        // SerialUSB.println("data1: "+String(temp1)+" ");
        // // uint64_t temp_64=0;
        for (uint16_t m = 0; m < 228; m++)
        {
            data_in0[m] = 0;
            data_in1[m] = 0;
            data_in2[m] = 0;
        }
        for (uint16_t j = 0; j < 228; j++)
        {
            // data_in0[j]=(data_in01[j]|temp_64)|(data_in02[j]<<32);
            // data_in1[j]=(data_in11[j]|temp_64)|(data_in12[j]<<32);
            // data_in2[j]=(data_in21[j]|temp_64)|(data_in22[j]<<32);
            data_in0[j] = (((data_in0[j] | data_in02[j]) << 32) | data_in01[j]);
            data_in1[j] = (((data_in1[j] | data_in12[j]) << 32) | data_in11[j]);
            data_in2[j] = (((data_in2[j] | data_in22[j]) << 32) | data_in21[j]);
        }
        // for debugging
        // temp=data_in0[0];
        // temp1=data_in0[0]>>32;
        // SerialUSB.println("data0: "+String(temp)+" ");
        // // temp=data_in1[0];
        // SerialUSB.println("data1: "+String(temp1)+" ");
        // temp=data_in0[89];
        // temp1=data_in0[89]>>32;
        // SerialUSB.println("data0: "+String(temp)+" ");
        // // temp=data_in1[0];
        // SerialUSB.println("data1: "+String(temp1)+" ");

        // temp=data_in2[0];
        // SerialUSB.println("data2: "+String(temp)+" ");
        // temp=data_in0[1];
        // SerialUSB.println("data0: "+String(temp)+" ");
        // temp=data_in1[1];
        // SerialUSB.println("data1: "+String(temp)+" ");
        // temp=data_in2[1];
        // SerialUSB.println("data2: "+String(temp)+" ");
        // Testing if the input data is incorrect
        // uint64_t Golden_data0[228]={3377699720527880,3377699720527876,2251799813685264,2251799814209536,3377699720528384,2251799813687296,3377699720593408,2251799813718016,3377699720528896,3377699720658944,2251799813685252,2251799813685280,2251799813816320,2251799813947392,3377699720529920,2251799813685376,2251799813685376,3377699720527936,3377699720529920,2251799813685760,3377699720527874,3377699720528128,2251799813686272,3377699720528128,3377699720529920,2251799813816320,3377699721052160,3377699720790016,2251799813718016,2251799813685249,2251799813689344,2251799813687296,3377699720529920,2251799813685312,3377699720527904,3377699721052160,2251799813947392,2251799813685312,2251799813685264,2251799813685256,3377699720529920,2251799813685264,3377699720527873,3377699721052160,3377699720531968,3377699720536064,2251799813685264,3377699720528384,2251799813718016,3377699720560640,2251799813701632,3377699720527880,2251799813685760,2251799813685376,3377699720536064,3377699720527873,2251799813689344,2251799813685312,3377699720527873,2251799813685250,3377699720544256,2251799813686272,2251799813685280,3377699720527888,2251799813685280,2251799813689344,3377699721052160,3377699720528128,2251799813685264,2251799813687296,2251799813816320,3377699720544256,3377699720528128,3377699720528384,3377699721052160,2251799813685504,2251799813685264,3377699720527874,2251799813816320,3377699720527936,2251799813701632,2251799813685250,3377699720529920,2251799813685250,3377699721052160,2251799813685264,2251799814209536,2251799813685504,2251799813947392,3377699720529920,3377699720527880,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
        // uint64_t Golden_data1[228]={2251799813816320,3377699720658944,2251799813685376,3377699720527936,2251799813689344,2251799813685504,3377699720790016,3377699720528128,2251799813685264,2251799813685760,3377699720528896,2251799813750784,3377699720536064,2251799813701632,3377699720658944,3377699720527880,2251799813685504,3377699720593408,2251799813685312,2251799813686272,2251799813701632,3377699720527904,3377699721052160,2251799813701632,2251799813685312,2251799813685250,3377699720529920,3377699720528896,3377699720658944,2251799813750784,3377699720544256,2251799813693440,2251799813693440,3377699720560640,3377699720528384,3377699720536064,3377699720593408,3377699720527873,3377699720529920,2251799813685504,2251799813686272,3377699720790016,3377699720560640,2251799813693440,2251799813685256,3377699720527936,3377699720528128,3377699720527873,2251799813701632,3377699720527876,2251799813685760,2251799813701632,2251799813718016,3377699720529920,2251799813685280,3377699720527904,2251799813685264,2251799813685250,2251799814209536,2251799813689344,3377699720658944,3377699720536064,2251799813701632,2251799813687296,3377699720593408,3377699720527888,2251799813685249,2251799813750784,3377699720790016,3377699720528000,3377699720536064,2251799813685504,2251799813685264,2251799813947392,3377699720528128,2251799813685250,3377699720531968,2251799813685760,3377699720527876,2251799813685504,2251799813685280,3377699720527876,3377699720527876,2251799813685252,2251799813701632,2251799813750784,2251799813816320,3377699720527873,3377699720528128,2251799813685250,2251799813718016,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
        // uint64_t Golden_data2[228]={3377699720790016,2251799813685264,2251799813701632,2251799813718016,2251799813685312,3377699720593408,3377699720527888,3377699720544256,2251799813693440,3377699720531968,3377699720529920,2251799813685376,3377699720527873,3377699720528384,2251799813947392,3377699720527936,3377699720527880,2251799813701632,2251799813693440,3377699720528000,2251799813686272,3377699720527873,2251799813750784,3377699720531968,2251799813750784,3377699721052160,3377699720527880,3377699720536064,2251799813685256,2251799813947392,3377699720528384,2251799813689344,2251799813685312,3377699720528384,3377699720527936,2251799813718016,3377699720528896,2251799814209536,3377699720544256,2251799813689344,2251799813685312,2251799813685376,3377699720593408,2251799813701632,3377699720528384,3377699720528384,3377699721052160,2251799813947392,2251799813685249,2251799813686272,3377699720527880,2251799813685252,3377699720528896,2251799813685264,3377699720529920,3377699720528896,2251799813685249,3377699720529920,3377699720790016,2251799813685376,3377699720527880,3377699720528128,2251799813685250,2251799813701632,3377699720527888,2251799813947392,3377699720536064,3377699720544256,2251799813816320,2251799813685760,2251799813685256,3377699720531968,2251799813685249,2251799813693440,3377699720527880,3377699720790016,2251799813750784,2251799813816320,3377699720528896,3377699720593408,2251799813685252,2251799813689344,2251799813685250,3377699720593408,2251799813718016,2251799813947392,3377699720528896,2251799813685264,3377699720593408,3377699720593408,2251799813685264,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

        // uint32_t temp2=0;
        // uint32_t temp3=0;
        // for (uint16_t m=0;m<228;m++)
        // {
        //     if (data_in0[m]!=Golden_data0[m])
        //     {
        //         temp=data_in0[m];
        //         temp1=data_in0[m]>>32;
        //         temp2=Golden_data0[m];
        //         temp3=Golden_data0[m]>>32;
        //         SerialUSB.println("Incorrect: data0["+String(m)+"]: "+String(temp)+" / "+String(temp1)+"v.s."+String(temp2)+" / " +String(temp3)+" ");
        //     }
        //     if (data_in1[m]!=Golden_data1[m])
        //     {
        //         temp=data_in1[m];
        //         temp1=data_in1[m]>>32;
        //         temp2=Golden_data1[m];
        //         temp3=Golden_data1[m]>>32;
        //         SerialUSB.println("Incorrect: data1["+String(m)+"]: "+String(temp)+" / "+String(temp1)+"v.s."+String(temp2)+" / " +String(temp3)+" ");
        //     }
        //     if (data_in2[m]!=Golden_data2[m])
        //     {
        //         temp=data_in2[m];
        //         temp1=data_in2[m]>>32;
        //         temp2=Golden_data2[m];
        //         temp3=Golden_data2[m]>>32;
        //         SerialUSB.println("Incorrect: data2["+String(m)+"]: "+String(temp)+" / "+String(temp1)+"v.s."+String(temp2)+" / " +String(temp3)+" ");
        //     }
        //     // data_in1[m]=Golden_data1[m];
        //     // data_in2[m]=Golden_data2[m];
        // }

        Scan_chain_data_program(die, data_in0, data_in1, data_in2, 0);
        delayMicroseconds(500);

        for (uint16_t runtime = 0; runtime < runNum; runtime++)
        {
            delayMicroseconds(100);
            writeReg(CONTROL_REGS + PC_CONTINUE * 4, 0x00000001);
            // (I have changed the index from i to 0)
            char samplesChar[strLen]; // Initialize char array

            String samplesStr = "/data_out_" + String(folderName) + ".csv"; // Concatenate file path as String
            strLen = samplesStr.length() + 1;                               // Calculate length of String
            samplesStr.toCharArray(samplesChar, strLen);                    // Copy file path to char array

            // retrieveSamples(samples);                               // Retrieve sampled data
            bool reg_data_chip0_pause = 0;
            // bool reg_data_chip0_term = 0;
            if (die == 0)
            {
                while (1)
                {
                    reg_data_chip0_pause = digitalReadFast(SYS_PAUSE_DIE1);
                    // reg_data_chip0_term = digitalReadFast(SYS_TERM_DIE1);
                    if (reg_data_chip0_pause == 1)
                    {
                        break;
                    }
                }
            }
            else
            {
                while (1)
                {
                    reg_data_chip0_pause = digitalReadFast(SYS_PAUSE_DIE2);
                    // reg_data_chip0_term = digitalReadFast(SYS_TERM_DIE2);
                    if (reg_data_chip0_pause == 1)
                    {
                        break;
                    }
                }
            }
            uint32_t reg_data_chip0 = 0;
            reg_data_chip0 = readReg(CONTROL_REGS + STATUS_SYS_INFO * 4);
            if ((reg_data_chip0 & 0x00000002) == 0x00000000)
            {
                Read_sample_registers(sampled_data);
            }
            else
            {
                // continue;
                Read_sample_registers(sampled_data);
            }
            uint32_t total_cycles = 0;

            // uint32_t summation =0;
            total_cycles = readReg(CONTROL_REGS + STATUS_TOTAL_CYC * 4);
            restart_counter_now = readReg(CONTROL_REGS + STATUS_RESTRT_CNT * 4);                                // Restart counter means that how many runs it runs ==> It will be 1 if there is no timeout.
            sampled_data[14] = total_cycles + (restart_counter_now - restart_counter_previous) * timeout_value; // Retrieve total execution cycles
            restart_counter_previous = restart_counter_now;
            // sampled_data[14] =readReg(CONTROL_REGS+STATUS_TOTAL_CYC*4);
            // last two row for fast testing
            // uint32_t formatted_data[2];
            // formatted_data[0]=0;
            // formatted_data[1]=0;
            // Change_data_format(sampled_data,formatted_data);
            // sampled_data[15]=formatted_data[0];
            // sampled_data[16]=formatted_data[1];

            // print the formatted data
            //  SerialUSB.println("formatted_data0: "+String(sampled_data[15])+" ");
            //  SerialUSB.println("formatted_data1: "+String(sampled_data[16])+" ");
            if (runtime == 0)
            {
                writeCSV(samplesChar, how_many_runs, 1);
            }
            appendCSV(samplesChar, sampled_data, 15);
        }
        if ((runNum > 1))
        {
            SerialUSB.println("Problem " + String(i) + ": Complete");
        }
        // appendCSV(samplesChar, sampled_data, 17);
        // if (i==0)
        // {
        //     writeCSV(samplesChar, sampled_data, 15);                     // Write to SD card
        // }
        // else
        // {
        //     appendCSV(samplesChar, sampled_data, 15);                     // Write to SD card
        // }
        // SerialUSB.println("Dataset " + String(i) + ": Complete");
        // if (i%100==0)
        // {
        //     SerialUSB.println("Dataset " + String(i) + ": Complete");
        // }
        // if (i%1000 == 0)
        // {
        //     SerialUSB.println("Dataset " + String(i) + ": Complete");
        // }
        // delay(1000);
    }

    
}
void DAEDALUS::batchRunLoop_power_measurement(String batchname, String Output_batchname, uint32_t problems, uint16_t runNum, bool uf20_or50, bool die, uint32_t timeout_value)
{
    // uint32_t softInfo[24] = {0};    // Preallocate array for soft info
    // uint32_t samples[25] = {0};     // Preallocate array for output data

    uint64_t data_in0[228];
    uint64_t data_in1[228];
    uint64_t data_in2[228];

    uint32_t data_in01[228];
    uint32_t data_in11[228];
    uint32_t data_in21[228];

    uint32_t data_in02[228];
    uint32_t data_in12[228];
    uint32_t data_in22[228];

    // uint64_t data_out0[228];
    // uint64_t data_out1[228];
    // uint64_t data_out2[228];
    uint32_t how_many_runs[2] = {runNum, runNum};
    // uint32_t sampled_data[17];  //Output data// 0:how many runs,
    uint32_t sampled_data[15]; // Output data// 0:how many runs,
    // uint32_t test_results[3];
    String dataFolderStr;
    uint16_t strLen;
    if (uf20_or50)
    {
        dataFolderStr = "/Iterations/" + Output_batchname + "/" + batchname;
        strLen = dataFolderStr.length() + 1;
        char dataFolderChar[strLen];
        dataFolderStr.toCharArray(dataFolderChar, strLen);
        SD.mkdir(dataFolderChar);
    }
    else
    {
        dataFolderStr = "/Iterations/" + Output_batchname + "/" + batchname;
        strLen = dataFolderStr.length() + 1;
        char dataFolderChar[strLen];
        dataFolderStr.toCharArray(dataFolderChar, strLen);
        SD.mkdir(dataFolderChar);
    }
    uint32_t restart_counter_previous = 1;
    uint32_t restart_counter_now = 1;
    // for (uint32_t i = 1; i < problems+1; i++)
    // Needs to be changed back
    for (uint32_t i = 393; i < problems + 1; i++)
    {

        String test_problem;
        if (uf20_or50)
        {
            test_problem = "/uf20-0";
        }
        else
        {
            test_problem = "/uf50-0";
        }

        //     // Load data from SD card (I have changed the index from i to 0)
        String Data_Info_01 = batchname + test_problem + String(i) + "/data_info_01.csv"; // Concatenate file path as String
        strLen = Data_Info_01.length() + 1;                                               // Calculate length of String
        char Data_Info_name_01[strLen];                                                   // Initialize char array
        Data_Info_01.toCharArray(Data_Info_name_01, strLen);                              // Copy file path to char array

        String Data_Info_02 = batchname + test_problem + String(i) + "/data_info_02.csv"; // Concatenate file path as String
        strLen = Data_Info_02.length() + 1;                                               // Calculate length of String
        char Data_Info_name_02[strLen];                                                   // Initialize char array
        Data_Info_02.toCharArray(Data_Info_name_02, strLen);                              // Copy file path to char array

        String Data_Info_11 = batchname + test_problem + String(i) + "/data_info_11.csv"; // Concatenate file path as String
        strLen = Data_Info_11.length() + 1;                                               // Calculate length of String
        char Data_Info_name_11[strLen];                                                   // Initialize char array
        Data_Info_11.toCharArray(Data_Info_name_11, strLen);                              // Copy file path to char array

        String Data_Info_12 = batchname + test_problem + String(i) + "/data_info_12.csv"; // Concatenate file path as String
        strLen = Data_Info_12.length() + 1;                                               // Calculate length of String
        char Data_Info_name_12[strLen];                                                   // Initialize char array
        Data_Info_12.toCharArray(Data_Info_name_12, strLen);                              // Copy file path to char array

        String Data_Info_21 = batchname + test_problem + String(i) + "/data_info_21.csv"; // Concatenate file path as String
        strLen = Data_Info_21.length() + 1;                                               // Calculate length of String
        char Data_Info_name_21[strLen];                                                   // Initialize char array
        Data_Info_21.toCharArray(Data_Info_name_21, strLen);                              // Copy file path to char array

        String Data_Info_22 = batchname + test_problem + String(i) + "/data_info_22.csv"; // Concatenate file path as String
        strLen = Data_Info_22.length() + 1;                                               // Calculate length of String
        char Data_Info_name_22[strLen];                                                   // Initialize char array
        Data_Info_22.toCharArray(Data_Info_name_22, strLen);                              // Copy file path to char array

        // }

        readCSV(Data_Info_name_01, data_in01, 228); // Read problems from SD card
        readCSV(Data_Info_name_02, data_in02, 228); // Read problems from SD card
        readCSV(Data_Info_name_11, data_in11, 228); // Read problems from SD card
        readCSV(Data_Info_name_12, data_in12, 228); // Read problems from SD card
        readCSV(Data_Info_name_21, data_in21, 228); // Read problems from SD card
        readCSV(Data_Info_name_22, data_in22, 228); // Read problems from SD card

        for (uint16_t m = 0; m < 228; m++)
        {
            data_in0[m] = 0;
            data_in1[m] = 0;
            data_in2[m] = 0;
        }
        for (uint16_t j = 0; j < 228; j++)
        {

            data_in0[j] = (((data_in0[j] | data_in02[j]) << 32) | data_in01[j]);
            data_in1[j] = (((data_in1[j] | data_in12[j]) << 32) | data_in11[j]);
            data_in2[j] = (((data_in2[j] | data_in22[j]) << 32) | data_in21[j]);
        }

        Scan_chain_data_program(die, data_in0, data_in1, data_in2, 0);
        //        delay(1000);

        // for (uint16_t runtime = 0; runtime <runNum;runtime++)
        while (1)
        {
            delayMicroseconds(100);
            writeReg(CONTROL_REGS + PC_CONTINUE * 4, 0x00000001);
            // (I have changed the index from i to 0)
            // char samplesChar[strLen];                                                   // Initialize char array
            // if (uf20_or50)
            // {
            //     String samplesStr = dataFolderStr + "/data_out_uf20-0" + String(i) + ".csv";         // Concatenate file path as String
            //     strLen = samplesStr.length() + 1;                                           // Calculate length of String
            //     samplesStr.toCharArray(samplesChar, strLen);                                // Copy file path to char array
            // }
            // else
            // {
            //     String samplesStr = dataFolderStr + "/data_out_uf50-0" + String(i) + ".csv";         // Concatenate file path as String
            //     strLen = samplesStr.length() + 1;                                           // Calculate length of String
            //     samplesStr.toCharArray(samplesChar, strLen);                                // Copy file path to char array
            // }

            bool reg_data_chip0_pause = 0;
            if (die == 0)
            {
                while (1)
                {
                    reg_data_chip0_pause = digitalReadFast(SYS_PAUSE_DIE1);
                    if (reg_data_chip0_pause == 1)
                    {
                        break;
                    }
                }
            }
            else
            {
                while (1)
                {
                    reg_data_chip0_pause = digitalReadFast(SYS_PAUSE_DIE2);
                    if (reg_data_chip0_pause == 1)
                    {
                        break;
                    }
                }
            }
            // uint32_t reg_data_chip0 = 0;
            // reg_data_chip0 = readReg(CONTROL_REGS+STATUS_SYS_INFO*4);
            // if ((reg_data_chip0 & 0x00000002)==0x00000000)
            // {
            //     Read_sample_registers(sampled_data);
            // }
            // else
            // {
            //     Read_sample_registers(sampled_data);
            // }
            // uint32_t total_cycles = 0;

            // total_cycles = readReg(CONTROL_REGS+STATUS_TOTAL_CYC*4);
            // restart_counter_now = readReg(CONTROL_REGS+STATUS_RESTRT_CNT*4);  //Restart counter means that how many runs it runs ==> It will be 1 if there is no timeout.
            // sampled_data[14] = total_cycles + (restart_counter_now-restart_counter_previous)*timeout_value;    // Retrieve total execution cycles
            // restart_counter_previous = restart_counter_now;

            // {
            //     writeCSV(samplesChar, how_many_runs, 1);
            // }
            // appendCSV(samplesChar, sampled_data, 15);
        }
        // if((runNum>1))
        // {
        //     SerialUSB.println("Problem " + String(i) + ": Complete");
        // }
        // appendCSV(samplesChar, sampled_data, 17);
        // if (i==0)
        // {
        //     writeCSV(samplesChar, sampled_data, 15);                     // Write to SD card
        // }
        // else
        // {
        //     appendCSV(samplesChar, sampled_data, 15);                     // Write to SD card
        // }
        // SerialUSB.println("Dataset " + String(i) + ": Complete");
        // if (i%100==0)
        // {
        //     SerialUSB.println("Dataset " + String(i) + ": Complete");
        // }
        // if (i%1000 == 0)
        // {
        //     SerialUSB.println("Dataset " + String(i) + ": Complete");
        // }
    }
}

void DAEDALUS::Calibration(bool die, uint8_t CS, bool clkExt, uint8_t clkIntFrq, uint8_t clkDiv)
{
    uint8_t sweep_variable[8] = {3, 5, 7, 10, 6, 6, 3, 14};
    uint8_t I_VCM_IMF_init = 0;
    uint8_t I_Clause_init = 2; // should be 2
    uint8_t I_Comp_init = 4;
    uint8_t I_RXO_init = 5;
    uint8_t I_FLASH_init = 3;
    uint8_t I_TIA_init = 4;
    uint8_t I_Analog_counter_init = 4;
    uint8_t I_timeout_value_init = 0;

    uint16_t Ibiases[14] = {9, 13, 35, 150, 16, 37, 13, 9, 13, 35, 35, 16, 37, 13};
    // uint16_t runNum = 100;
    uint16_t runNum = 100;
    uint16_t problemNum = 1000;
    // uint16_t problemNum=240;//For 20variables
    // uint16_t problemNum=393;//For 50variables / Power measurement

    // Sweep_Variable [0]
    //  float VCM_IMF[4]={0.9,0.73,0.55,0};
    //  float VCM_IMF[4]={0.9,0.722,0.55,0};  //for 50variables
    //  float VCM_IMF[4]={0.9,0.73,0.55,0};     // For 20variables oscillating mode
    float VCM_IMF[4] = {0.9, 0.729, 0.55, 0}; // For 50variables oscillating mode
    // Sweep_Variable [1]
    float Vref_FL0[5] = {0.05, 0.07, 0.095, 0.105, 0.12}; // 0.08, 0.12, 0.17, 0.19, 0.22
    float Vref_FL1[5] = {0.11, 0.17, 0.245, 0.275, 0.32};
    float Vref_FL2[5] = {0.17, 0.27, 0.395, 0.445, 0.52};
    float VCM_FLASH[5] = {0.11, 0.17, 0.245, 0.275, 0.32};
    uint16_t Ibias5_Clause[5] = {60, 37, 26, 23, 20}; // Singl
    // uint16_t Ibias5_Clause[5]={93,56,37,33,28}; //Single:3u, 5u, 7.5u, 8.5u, 10u ==>Ibias: 7.6u, 12.7u, 19u, 21.5u, 25.3u
    // Sweep_Variable [2]
    // uint16_t Ibias0_Comp[7]={68,27,17,12,9,8,7}; //coarse tune 20 variables
    // uint16_t Ibias0_Comp[6]={68,24,12,8,5,4}; //coarse tune 50 variables
    // uint16_t Ibias0_Comp[10]={23,20,17,14,11,8,5,4,3,2};  // fine tune 20 variables
    uint16_t Ibias0_Comp[6] = {12, 8, 5, 4, 3, 2}; // fine tune 50 variables
    // Sweep_Variable [3]
    //  uint16_t Ibias3_RXO[11]={525,300,140,70,47,35,28,23,20,18,18}; //coarse tune 50 variables
    uint16_t Ibias3_RXO[10] = {130, 120, 100, 80, 60, 55, 50, 45, 40, 35}; // fine fune 50 variables
    // uint16_t Ibias3_RXO[10]={65,60,55,50,45,40,35,30,25,20}; //fine fune 20 variables
    // uint16_t range_RXO[7] = {2,3,5,6,7,8,9};
    // Sweep_Variable [4]
    // uint16_t Ibias1_Flash[6]={23,18,15,13,11,10};
    uint16_t Ibias1_Flash[8] = {23, 18, 15, 13, 11, 10, 9, 8};
    // Sweep_Variable [5]
    //  uint16_t Ibias6_TIA[7]={30,23,18,15,13,11,10};
    //  uint16_t Ibias6_TIA[14]={30,23,18,15,13,11,10,9,8,7,6,5,4,3};
    uint16_t Ibias6_TIA[8] = {23, 18, 15, 13, 11, 10, 9, 8};
    // Initialization
    //  {3,5,7,10,6,6};
    //  uint8_t Analog_counter[15]={1,2,3,4,5,6,7,8,10,12,16,18,20,25,32};
    uint8_t Analog_counter[7] = {1, 2, 4, 8, 16, 16, 63};
    // uint32_t timeout_value[4]={23800,71400,142800,0x000fffff}; //100 300 600 fff
    // uint32_t timeout_value[2]={23800,0x000fffff};
    // uint32_t timeout_value[2]={71400,142800};
    uint32_t timeout_value[4] = {952, 2380, 4760, 0x000fffff}; // 4u, 10u,20u, inf

    sweep_variable[0] = 1;
    sweep_variable[1] = 3;

    // sweep_variable[2]=1;
    // sweep_variable[3]=4;
    // sweep_variable[2]=2;
    // sweep_variable[3]=11;
    sweep_variable[2] = 6;
    sweep_variable[3] = 10;

    sweep_variable[4] = 8;
    sweep_variable[5] = 8;
    sweep_variable[6] = 4;
    sweep_variable[7] = 4;

    // I_VCM_IMF_init =0;
    // I_Clause_init =0;

    // I_Comp_init =0;
    // I_RXO_init =2;

    // I_FLASH_init =0;
    // I_TIA_init =0;
    bool Latch_OSC_mode = 1; // Latching:1, Oscillating:0

    // Best bias point for 50 variables [0.90_37_2_60_15_8_8_0x000fffff]
    //  I_VCM_IMF_init =1;
    //  I_Clause_init =1;
    //  I_Comp_init =5;
    //  I_RXO_init =4;
    //  I_FLASH_init =2;
    //  I_TIA_init =7;
    //  I_Analog_counter_init = 3;
    //  I_timeout_value_init = 3;

    // Best bias point for 20 variables [0.90_37_2_35_10_11_4_0x000fffff]
    I_VCM_IMF_init = 1;
    I_Clause_init = 1; // should be 2
    I_Comp_init = 5;
    I_RXO_init = 9;
    I_FLASH_init = 5;
    I_TIA_init = 4;
    // I_Analog_counter_init = 2;
    I_timeout_value_init = 3;

    // Bias point for 2sat/small problems requiring longer samplign for metastability
    // based on 20 variable
    I_VCM_IMF_init = 1;
    I_Clause_init = 1; // should be 2
    I_Comp_init = 5;
    I_RXO_init = 9;
    I_FLASH_init = 5;
    I_TIA_init = 4;
    I_Analog_counter_init = 5;
    I_timeout_value_init = 3;

    uint8_t I_VCM_IMF = I_VCM_IMF_init;
    uint8_t I_Clause = I_Clause_init;
    uint8_t I_Comp = I_Comp_init;
    uint8_t I_RXO = I_RXO_init;
    uint8_t I_FLASH = I_FLASH_init;
    uint8_t I_TIA = I_TIA_init;
    uint8_t I_Analog_counter = I_Analog_counter_init;
    uint8_t I_timeout_value = I_timeout_value_init;

    // uint32_t timeout_value = 0x000fffff; //this value should be the RXO timeout value ==>around 4m seconds
    // timeout_value =71400; //300us
    // timeout_value =119000; //500us
    // timeout_value =190400; //500us
    // for (uint8_t I_VCM_IMF=I_VCM_IMF_init;I_VCM_IMF<sweep_variable[0];I_VCM_IMF++)
    // {
    // for (uint8_t I_Clause=I_Clause_init;I_Clause<sweep_variable[1];I_Clause++)
    // {
    // for (uint8_t I_Comp=I_Comp_init;I_Comp<sweep_variable[2];I_Comp++)
    // {
    // for (uint8_t I_RXO=I_RXO_init;I_RXO<sweep_variable[3];I_RXO++)
    // {
    // for (uint8_t I_FLASH=I_FLASH_init;I_FLASH<sweep_variable[4];I_FLASH++)
    // {
    // for (uint8_t I_TIA=I_TIA_init;I_TIA<sweep_variable[5];I_TIA++)
    // {
    // for (uint8_t I_Analog_counter=I_Analog_counter_init;I_Analog_counter<sweep_variable[6];I_Analog_counter++)
    // {
    // for (uint8_t I_timeout_value=I_timeout_value_init;I_timeout_value<sweep_variable[7];I_timeout_value++)
    // {
    Ibiases[0] = Ibias0_Comp[I_Comp];
    Ibiases[1] = Ibias1_Flash[I_FLASH];
    Ibiases[2] = 35; // DLL 35==>20uA==>unlock, 525==>1.5uA==locked
    Ibiases[3] = Ibias3_RXO[I_RXO];
    Ibiases[4] = 16; // IMF Bleed
    Ibiases[5] = Ibias5_Clause[I_Clause];
    Ibiases[6] = Ibias6_TIA[I_TIA];
    Ibiases[7] = Ibias0_Comp[I_Comp];
    Ibiases[8] = Ibias1_Flash[I_FLASH];
    Ibiases[9] = 35; // DLL 35==>20uA==>unlock, 525==>1.5uA==locked
    Ibiases[10] = Ibias3_RXO[I_RXO];
    Ibiases[11] = 16; // IMF Bleed1
    Ibiases[12] = Ibias5_Clause[I_Clause];
    Ibiases[13] = Ibias6_TIA[I_TIA];
    // DAC Different Vref0=0.5, Vref1=0.4, Vref2=0.3, Vref3=0.2
    //  DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.5, 0.3, Vref_FL1[I_Clause], 0.925, 0.925, 0.2, VCM_IMF[I_VCM_IMF], 0.5, 0.4, 0.55, VCM_FLASH[I_Clause]);
    // DAC all the same Vref0~3=0.5
    //  DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.5, 0.5, Vref_FL1[I_Clause], 0.925, 0.925, 0.5, VCM_IMF[I_Clause], 0.5, 0.5, 0.55, VCM_FLASH[I_Clause]);
    // DAC all the same Vref0~3=0.4
    //  DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.5, 0.4, Vref_FL1[I_Clause], 0.925, 0.925, 0.4, VCM_IMF[I_Clause], 0.4, 0.4, 0.55, VCM_FLASH[I_Clause]);

    // Oscillating mode settings
    //  DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.48, 0.3, Vref_FL1[I_Clause], 0.925, 0.925, 0.2, VCM_IMF[I_VCM_IMF], 0.5, 0.4, 0.55, VCM_FLASH[I_Clause]);  // Oscillating mode 20 Variables
    //  DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.48, 0.3, Vref_FL1[I_Clause], 0.924, 0.925, 0.2, VCM_IMF[I_VCM_IMF], 0.5, 0.4, 0.55, VCM_FLASH[I_Clause]); // Oscillating mode 20 Variables idle
    //  DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.48, 0.3, Vref_FL1[I_Clause], 0.947, 0.925, 0.2, VCM_IMF[I_VCM_IMF], 0.5, 0.4, 0.55, VCM_FLASH[I_Clause]); // Oscillating mode 20 Variables running

    DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.46, 0.3, Vref_FL1[I_Clause], 0.925, 0.925, 0.2, VCM_IMF[I_VCM_IMF], 0.5, 0.4, 0.55, VCM_FLASH[I_Clause]); // Oscillating mode 50 Variables
    // DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.46, 0.3, Vref_FL1[I_Clause], 0.912, 0.925, 0.2, VCM_IMF[I_VCM_IMF], 0.5, 0.4, 0.55, VCM_FLASH[I_Clause]); //Oscillating mode 50 Variables idle
    // DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.46, 0.3, Vref_FL1[I_Clause], 0.955, 0.925, 0.2, VCM_IMF[I_VCM_IMF], 0.5, 0.4, 0.55, VCM_FLASH[I_Clause]);  // Oscillating mode 50 Variables running
    // Power measurement
    // DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.5, 0.3, Vref_FL1[I_Clause], 0.913, 0.925, 0.2, VCM_IMF[I_VCM_IMF], 0.5, 0.4, 0.55, VCM_FLASH[I_Clause]);  //For 50 variables //idle
    // DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.5, 0.3, Vref_FL1[I_Clause], 0.95, 0.925, 0.2, VCM_IMF[I_VCM_IMF], 0.5, 0.4, 0.55, VCM_FLASH[I_Clause]);  //For 50 variables /running
    // DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.5, 0.3, Vref_FL1[I_Clause], 0.933, 0.925, 0.2, VCM_IMF[I_VCM_IMF], 0.5, 0.4, 0.55, VCM_FLASH[I_Clause]);  //For 50 variables /running

    // DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.5, 0.3, Vref_FL1[I_Clause], 0.923, 0.925, 0.2, VCM_IMF[I_VCM_IMF], 0.5, 0.4, 0.55, VCM_FLASH[I_Clause]);  //For 20 variables //idle
    // DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.5, 0.3, Vref_FL1[I_Clause], 0.934, 0.925, 0.2, VCM_IMF[I_VCM_IMF], 0.5, 0.4, 0.55, VCM_FLASH[I_Clause]);  //For 20 variables //ruunning
    // DAC_setup(Vref_FL2[I_Clause], Vref_FL0[I_Clause], 0.5, 0.3, Vref_FL1[I_Clause], 0.935, 0.925, 0.2, VCM_IMF[I_VCM_IMF], 0.5, 0.4, 0.55, VCM_FLASH[I_Clause]);  //For 20 variables //ruunning_and idle

    IBIAS_setup(Ibiases);
    //                                    delay(1000);
    setup_iteration(CS, clkExt, clkIntFrq, clkDiv);
    General_setup_for_dummy(die, Analog_counter[I_Analog_counter], timeout_value[I_timeout_value], Latch_OSC_mode); // mode ==1 ==> latching mode
    String iteration_name = "Iteration_[" + String(VCM_IMF[I_VCM_IMF]) + "_" + String(Ibias5_Clause[I_Clause]) + "_" + String(Ibias0_Comp[I_Comp]) + "_" + String(Ibias3_RXO[I_RXO]) + "_" + String(Ibias1_Flash[I_FLASH]) + "_" + String(Ibias6_TIA[I_TIA]) + "_" + String(Analog_counter[I_Analog_counter]) + "_" + String(timeout_value[I_timeout_value]) + "]";
    //                                    delay(5000);
    // batchRunLoop("uf20-91", iteration_name, problemNum, runNum,1,die,timeout_value[I_timeout_value]);
    batchRunLoop("uf50-218", iteration_name, problemNum, runNum, 0, die, timeout_value[I_timeout_value]);
    // batchRunLoop_power_measurement("uf50-218", iteration_name, problemNum, runNum,0,die,timeout_value[I_timeout_value]);
    // batchRunLoop_power_measurement("uf20-91", iteration_name, problemNum, runNum,1,die,timeout_value[I_timeout_value]);
    // SerialUSB.println("Dataset " + String(iteration_name) + ": Complete");
    // }
    // }
    // }
    // }
    // }
    // }
    // }
    // }
    SerialUSB.println("All the Iterations Complete");
}

// void DAEDALUS::batchRunLoop(String batchname, uint32_t *softInfo, uint32_t *dataOut, uint32_t length, uint8_t runNum)
// {
//     uint32_t inputs[24] = {0};  // Preallocate array for soft info
//     uint32_t samples[25] = {0}; // Preallocate array for output data

//     // Prepare file path for data output
//     String dataFolderStr = batchname + "/dout" + String(runNum) + ".bin";
//     uint8_t strLen = dataFolderStr.length() + 1;
//     char dataFolderChar[strLen];
//     dataFolderStr.toCharArray(dataFolderChar, strLen);

//     for (uint32_t i = 0; i < length; i++)
//     {
//         // Retrieve soft info from memory
//         for (uint8_t j = 0; j < 24; j++)
//         {
//             inputs[j] = softInfo[i*24 + j];
//         }

//         loadSoftInfo(inputs); // Load soft info onto chip

//         writeReg(CONTROL_REGS | CTRL_CONF_PC_CONTINUE*4, 1);    // Resume from pause instruction

//         // while (!digitalReadFast(DONE_PIN))
//         // {
//         //     // Wait for done signal
//         // }

//         retrieveSamples(samples);                               // Retrieve sampled data
//         samples[24] = readReg(CONTROL_REGS | TOTAL_CYCLE*4);    // Retrieve total execution cycles

//         // Store data in output array
//         for (uint8_t j = 0; j < 25; j++)
//         {
//             dataOut[i*25 + j] = samples[j];
//         }
//     }

//     // Write to SD card
//     writeBin(dataFolderChar, dataOut, length*25);
// }

// /*
//     Data functions
// */
void DAEDALUS::loadSoftInfo(uint32_t *data)
{
    for (uint8_t i = 0; i < 24; i++)
    {
        writeReg((HARD_INFO_REGS | i * 4), data[i]);
    }
}

void DAEDALUS::retrieveSamples(uint32_t *data)
{
    for (uint8_t i = 0; i < 24; i++)
    {
        data[i] = readReg((SAMPLE_REGS | i * 4));
    }
}
void DAEDALUS::Read_sample_registers(uint32_t *data)
{
    for (uint8_t i = 0; i < 14; i++)
    {
        data[i] = readReg((SAMPLE_REGS | i * 4));
    }
}
void DAEDALUS::Change_data_format(uint32_t *oscillator_data0, uint32_t *formatted_data)
{
    bool oscillator_states[56];
    for (int j = 0; j < 52; j++)
    {
        oscillator_states[j] = 0;
    }
    for (int x = 0; x < 14; x++)
    {
        for (int y = 0; y < 4; y++)
        {
            if (y == 0)
            {
                oscillator_states[x * 4 + y] = ((oscillator_data0[x] & (0x00000008)) == (0x00000008));
            }
            else if (y == 1)
            {
                oscillator_states[x * 4 + y] = ((oscillator_data0[x] & (0x00000800)) == (0x00000800));
            }
            else if (y == 2)
            {
                oscillator_states[x * 4 + y] = ((oscillator_data0[x] & (0x00080000)) == (0x00080000));
            }
            else if (y == 3)
            {
                oscillator_states[x * 4 + y] = ((oscillator_data0[x] & (0x08000000)) == (0x08000000));
            }
        }
    }
    // uint64_t oscillator_states_selected = 0;
    formatted_data[0] = 0;
    formatted_data[1] = 0;
    for (int add = 0; add < 56; add++)
    {
        if (add < 32)
        {
            formatted_data[0] = formatted_data[0] | (oscillator_states[add] << add);
        }
        else
        {
            formatted_data[1] = formatted_data[1] | (oscillator_states[add] << (add - 32));
        }
    }
}